1422503332
2 3
9 libp3dxml 4 uZHm 12 panda3d.core 
149
238 10 ~TiXmlBase 0 6 387 21 TiXmlBase::~TiXmlBase 0 0 0
36
virtual TiXmlBase::~TiXmlBase(void);

239 5 Print 0 6 387 16 TiXmlBase::Print 0 1 1 356
/** All TinyXml classes can print themselves to a filestream
        or the string class (TiXmlString in non-STL mode, std::string
        in STL mode.) Either or both cfile and str can be null.
        
        This is a formatted print, and will insert 
        tabs and newlines.
        
        (For an unformatted stream, use the << operator.)
    */
64
virtual void TiXmlBase::Print(FILE *cfile, int depth) const = 0;

240 21 SetCondenseWhiteSpace 0 4 387 32 TiXmlBase::SetCondenseWhiteSpace 0 1 2 351
/** The world does not agree on whether white space should be kept or
        not. In order to make everyone happy, these global, static functions
        are provided to set whether or not TinyXml will condense all white space
        into a single space or not. The default is to condense. Note changing this
        value is not thread safe.
    */
60
static void TiXmlBase::SetCondenseWhiteSpace(bool condense);

241 21 IsWhiteSpaceCondensed 0 4 387 32 TiXmlBase::IsWhiteSpaceCondensed 0 1 3 43
/// Return the current white space setting.
51
static bool TiXmlBase::IsWhiteSpaceCondensed(void);

242 3 Row 0 4 387 14 TiXmlBase::Row 0 1 4 944
/** Return the position, in the original source file, of this node or attribute.
        The row and column are 1-based. (That is the first row and first column is
        1,1). If the returns values are 0 or less, then the parser does not have
        a row and column value.

        Generally, the row and column value will be set when the TiXmlDocument::Load(),
        TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
        when the DOM was created from operator>>.

        The values reflect the initial load. Once the DOM is modified programmatically
        (by adding or changing nodes and attributes) the new values will NOT update to
        reflect changes in the document.

        There is a minor performance cost to computing the row and column. Computation
        can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

        @sa TiXmlDocument::SetTabSize()
    */
31
int TiXmlBase::Row(void) const;

243 6 Column 0 4 387 17 TiXmlBase::Column 0 1 5 14
///< See Row()
34
int TiXmlBase::Column(void) const;

244 11 SetUserData 0 4 387 22 TiXmlBase::SetUserData 0 0 42
///< Set a pointer to arbitrary user data.
40
void TiXmlBase::SetUserData(void *user);

245 11 GetUserData 0 4 387 22 TiXmlBase::GetUserData 0 2 6 7 86
///< Get a pointer to arbitrary user data.

///< Get a pointer to arbitrary user data.
83
void *TiXmlBase::GetUserData(void);
void const *TiXmlBase::GetUserData(void) const;

246 5 Parse 0 6 387 16 TiXmlBase::Parse 0 1 8 0
104
virtual char const *TiXmlBase::Parse(char const *p, TiXmlParsingData *data, TiXmlEncoding encoding) = 0;

247 12 EncodeString 0 4 387 23 TiXmlBase::EncodeString 0 1 9 146
/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
        or they will be transformed into entities!
    */
96
static void TiXmlBase::EncodeString(basic_string< char > const &str, basic_string< char > *out);

248 5 Value 0 4 390 16 TiXmlNode::Value 0 1 19 368
/** The meaning of 'value' changes for the specific type of
        TiXmlNode.
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim

        The subclasses will wrap this function.
    */
41
char const *TiXmlNode::Value(void) const;

249 8 ValueStr 0 4 390 19 TiXmlNode::ValueStr 0 1 20 153
/** Return Value() as a std::string. If you only use STL,
        this is more efficient than calling Value().
        Only available in STL mode.
    */
60
basic_string< char > const &TiXmlNode::ValueStr(void) const;

250 9 ValueTStr 0 4 390 20 TiXmlNode::ValueTStr 0 1 21 0
61
basic_string< char > const &TiXmlNode::ValueTStr(void) const;

251 8 SetValue 0 4 390 19 TiXmlNode::SetValue 0 2 22 23 314
/** Changes the value of the node. Defined as:
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim
    */

/// STL std::string form.
107
void TiXmlNode::SetValue(char const *_value);
void TiXmlNode::SetValue(basic_string< char > const &_value);

252 5 Clear 0 4 390 16 TiXmlNode::Clear 0 1 24 65
/// Delete all the children of this node. Does not affect 'this'.
28
void TiXmlNode::Clear(void);

253 6 Parent 0 4 390 17 TiXmlNode::Parent 0 2 25 26 24
/// One step up the DOM.
83
TiXmlNode *TiXmlNode::Parent(void);
TiXmlNode const *TiXmlNode::Parent(void) const;

254 10 FirstChild 0 4 390 21 TiXmlNode::FirstChild 0 6 27 28 29 30 31 32 382
///< The first child of this node. Will be null if there are no children.

///< The first child of this node. Will be null if there are no children.

///< The first child of this node with the matching 'value'. Will be null if none found.
/// The first child of this node with the matching 'value'. Will be null if none found.

///< STL std::string form.

///< STL std::string form.
362
TiXmlNode const *TiXmlNode::FirstChild(void) const;
TiXmlNode *TiXmlNode::FirstChild(void);
TiXmlNode const *TiXmlNode::FirstChild(char const *value) const;
TiXmlNode *TiXmlNode::FirstChild(char const *_value);
TiXmlNode const *TiXmlNode::FirstChild(basic_string< char > const &_value) const;
TiXmlNode *TiXmlNode::FirstChild(basic_string< char > const &_value);

255 9 LastChild 0 4 390 20 TiXmlNode::LastChild 0 6 33 34 35 36 37 38 380
/// The last child of this node. Will be null if there are no children.

/// The last child of this node. Will be null if there are no children.

/// The last child of this node matching 'value'. Will be null if there are no children.

/// The last child of this node matching 'value'. Will be null if there are no children.

///< STL std::string form.

///< STL std::string form.
356
TiXmlNode const *TiXmlNode::LastChild(void) const;
TiXmlNode *TiXmlNode::LastChild(void);
TiXmlNode const *TiXmlNode::LastChild(char const *value) const;
TiXmlNode *TiXmlNode::LastChild(char const *_value);
TiXmlNode const *TiXmlNode::LastChild(basic_string< char > const &_value) const;
TiXmlNode *TiXmlNode::LastChild(basic_string< char > const &_value);

256 15 IterateChildren 0 4 390 26 TiXmlNode::IterateChildren 0 6 39 40 41 42 43 44 747
/** An alternate way to walk the children of a node.
        One way to iterate over nodes is:
        @verbatim
            for( child = parent->FirstChild(); child; child = child->NextSibling() )
        @endverbatim

        IterateChildren does the same thing with the syntax:
        @verbatim
            child = 0;
            while( child = parent->IterateChildren( child ) )
        @endverbatim

        IterateChildren takes the previous child as input and finds
        the next one. If the previous child is null, it returns the
        first. IterateChildren will return null when done.
    */

/// This flavor of IterateChildren searches for children with a particular 'value'

///< STL std::string form.

///< STL std::string form.
542
TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous);
TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous);
TiXmlNode const *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(basic_string< char > const &_value, TiXmlNode const *previous);

257 14 InsertEndChild 0 4 390 25 TiXmlNode::InsertEndChild 0 1 45 148
/** Add a new node related to this. Adds a child past the LastChild.
        Returns a pointer to the new object or NULL if an error occured.
    */
63
TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis);

258 17 InsertBeforeChild 0 4 390 28 TiXmlNode::InsertBeforeChild 0 1 46 156
/** Add a new node related to this. Adds a child before the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */
89
TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis);

259 16 InsertAfterChild 0 4 390 27 TiXmlNode::InsertAfterChild 0 1 47 155
/** Add a new node related to this. Adds a child after the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */
87
TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis);

260 12 ReplaceChild 0 4 390 23 TiXmlNode::ReplaceChild 0 1 48 113
/** Replace a child of this node.
        Returns a pointer to the new object or NULL if an error occured.
    */
86
TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis);

261 11 RemoveChild 0 4 390 22 TiXmlNode::RemoveChild 0 1 49 32
/// Delete a child of this node.
51
bool TiXmlNode::RemoveChild(TiXmlNode *removeThis);

262 15 PreviousSibling 0 4 390 26 TiXmlNode::PreviousSibling 0 6 50 51 52 53 54 55 120
/// Navigate to a sibling node.

/// Navigate to a sibling node.

///< STL std::string form.

///< STL std::string form.
386
TiXmlNode const *TiXmlNode::PreviousSibling(void) const;
TiXmlNode *TiXmlNode::PreviousSibling(void);
TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const;
TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev);
TiXmlNode const *TiXmlNode::PreviousSibling(basic_string< char > const &_value) const;
TiXmlNode *TiXmlNode::PreviousSibling(basic_string< char > const &_value);

263 11 NextSibling 0 4 390 22 TiXmlNode::NextSibling 0 6 56 57 58 59 60 61 143
///< STL std::string form.

///< STL std::string form.

/// Navigate to a sibling node.

/// Navigate to a sibling node with the given 'value'.
362
TiXmlNode const *TiXmlNode::NextSibling(basic_string< char > const &_value) const;
TiXmlNode *TiXmlNode::NextSibling(basic_string< char > const &_value);
TiXmlNode const *TiXmlNode::NextSibling(void) const;
TiXmlNode *TiXmlNode::NextSibling(void);
TiXmlNode const *TiXmlNode::NextSibling(char const *) const;
TiXmlNode *TiXmlNode::NextSibling(char const *_next);

264 18 NextSiblingElement 0 4 390 29 TiXmlNode::NextSiblingElement 0 6 62 63 64 65 66 67 420
/** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */

/** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */

///< STL std::string form.

///< STL std::string form.
422
TiXmlElement const *TiXmlNode::NextSiblingElement(void) const;
TiXmlElement *TiXmlNode::NextSiblingElement(void);
TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const;
TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next);
TiXmlElement const *TiXmlNode::NextSiblingElement(basic_string< char > const &_value) const;
TiXmlElement *TiXmlNode::NextSiblingElement(basic_string< char > const &_value);

265 17 FirstChildElement 0 4 390 28 TiXmlNode::FirstChildElement 0 6 68 69 70 71 72 73 156
/// Convenience function to get through elements.

/// Convenience function to get through elements.

///< STL std::string form.

///< STL std::string form.
423
TiXmlElement const *TiXmlNode::FirstChildElement(void) const;
TiXmlElement *TiXmlNode::FirstChildElement(void);
TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const;
TiXmlElement *TiXmlNode::FirstChildElement(char const *_value);
TiXmlElement const *TiXmlNode::FirstChildElement(basic_string< char > const &_value) const;
TiXmlElement *TiXmlNode::FirstChildElement(basic_string< char > const &_value);

266 4 Type 0 4 390 15 TiXmlNode::Type 0 1 74 195
/** Query the type (as an enumerated value, above) of this node.
        The possible types are: DOCUMENT, ELEMENT, COMMENT,
                                UNKNOWN, TEXT, and DECLARATION.
    */
32
int TiXmlNode::Type(void) const;

267 11 GetDocument 0 4 390 22 TiXmlNode::GetDocument 0 2 75 76 106
/** Return a pointer to the Document this node lives in.
        Returns null if not in a document.
    */
101
TiXmlDocument const *TiXmlNode::GetDocument(void) const;
TiXmlDocument *TiXmlNode::GetDocument(void);

268 10 NoChildren 0 4 390 21 TiXmlNode::NoChildren 0 1 77 46
/// Returns true if this node has no children.
39
bool TiXmlNode::NoChildren(void) const;

269 10 ToDocument 0 6 390 21 TiXmlNode::ToDocument 0 2 78 79 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
115
virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const;
virtual TiXmlDocument *TiXmlNode::ToDocument(void);

270 9 ToElement 0 6 390 20 TiXmlNode::ToElement 0 2 80 81 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlElement const *TiXmlNode::ToElement(void) const;
virtual TiXmlElement *TiXmlNode::ToElement(void);

271 9 ToComment 0 6 390 20 TiXmlNode::ToComment 0 2 82 83 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlComment const *TiXmlNode::ToComment(void) const;
virtual TiXmlComment *TiXmlNode::ToComment(void);

272 9 ToUnknown 0 6 390 20 TiXmlNode::ToUnknown 0 2 84 85 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const;
virtual TiXmlUnknown *TiXmlNode::ToUnknown(void);

273 6 ToText 0 6 390 17 TiXmlNode::ToText 0 2 86 87 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
99
virtual TiXmlText const *TiXmlNode::ToText(void) const;
virtual TiXmlText *TiXmlNode::ToText(void);

274 13 ToDeclaration 0 6 390 24 TiXmlNode::ToDeclaration 0 2 88 89 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
127
virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const;
virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void);

275 5 Clone 0 6 390 16 TiXmlNode::Clone 0 1 90 115
/** Create an exact duplicate of this node and return it. The memory must be deleted
        by the caller. 
    */
52
virtual TiXmlNode *TiXmlNode::Clone(void) const = 0;

276 6 Accept 0 6 390 17 TiXmlNode::Accept 0 1 91 827
/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
        XML tree will be conditionally visited and the host will be called back
        via the TiXmlVisitor interface.

        This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
        the XML for the callbacks, so the performance of TinyXML is unchanged by using this
        interface versus any other.)

        The interface has been based on ideas from:

        - http://www.saxproject.org/
        - http://c2.com/cgi/wiki?HierarchicalVisitorPattern 

        Which are both good references for "visiting".

        An example of using Accept():
        @verbatim
        TiXmlPrinter printer;
        tinyxmlDoc.Accept( &printer );
        const char* xmlcstr = printer.CStr();
        @endverbatim
    */
64
virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0;

277 16 TiXmlDeclaration 0 4 389 34 TiXmlDeclaration::TiXmlDeclaration 0 4 10 11 12 13 69
/// Construct an empty declaration.

/// Constructor.

/// Construct.
367
TiXmlDeclaration::TiXmlDeclaration(void);
TiXmlDeclaration::TiXmlDeclaration(basic_string< char > const &_version, basic_string< char > const &_encoding, basic_string< char > const &_standalone);
TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone);
TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy);

278 10 operator = 0 4 389 28 TiXmlDeclaration::operator = 0 1 14 0
64
void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy);

279 7 Version 0 4 389 25 TiXmlDeclaration::Version 0 1 15 59
/// Version. Will return an empty string if none was found.
50
char const *TiXmlDeclaration::Version(void) const;

280 8 Encoding 0 4 389 26 TiXmlDeclaration::Encoding 0 1 16 60
/// Encoding. Will return an empty string if none was found.
51
char const *TiXmlDeclaration::Encoding(void) const;

281 10 Standalone 0 4 389 28 TiXmlDeclaration::Standalone 0 1 17 34
/// Is this a standalone document?
53
char const *TiXmlDeclaration::Standalone(void) const;

282 5 Print 0 6 389 23 TiXmlDeclaration::Print 0 1 18 54
// Print this declaration to a FILE stream.

/*depth*/
94
virtual void TiXmlDeclaration::Print(FILE *cfile, int depth, basic_string< char > *str) const;

283 13 TiXmlDocument 0 4 392 28 TiXmlDocument::TiXmlDocument 0 4 92 93 94 95 159
/// Create an empty document, that has no name.

/// Create a document with a name. The name of the document is also the filename of the xml.

/// Constructor.
220
TiXmlDocument::TiXmlDocument(void);
TiXmlDocument::TiXmlDocument(char const *documentName);
TiXmlDocument::TiXmlDocument(basic_string< char > const &documentName);
TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy);

284 10 operator = 0 4 392 25 TiXmlDocument::operator = 0 1 96 0
58
void TiXmlDocument::operator =(TiXmlDocument const &copy);

285 8 LoadFile 0 4 392 23 TiXmlDocument::LoadFile 0 8 97 98 99 100 101 102 103 104 573
/** Load a file using the current document value.
        Returns true if successful. Will delete any existing
        document data before loading.
    */

/// Load a file using the given filename. Returns true if successful.

/** Load a file using the given FILE*. Returns true if successful. Note that this method
        doesn't stream - the entire object pointed at by the FILE*
        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
        file location. Streaming may be added in the future.
    */

///< STL std::string version.
307
bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = (0));
bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = (0));
bool TiXmlDocument::LoadFile(FILE *, TiXmlEncoding encoding = (0));
bool TiXmlDocument::LoadFile(basic_string< char > const &filename, TiXmlEncoding encoding = (0));

286 8 SaveFile 0 4 392 23 TiXmlDocument::SaveFile 0 4 105 106 107 108 247
/// Save a file using the current document value. Returns true if successful.

/// Save a file using the given filename. Returns true if successful.

/// Save a file using the given FILE*. Returns true if successful.

///< STL std::string version.
217
bool TiXmlDocument::SaveFile(void) const;
bool TiXmlDocument::SaveFile(char const *filename) const;
bool TiXmlDocument::SaveFile(FILE *) const;
bool TiXmlDocument::SaveFile(basic_string< char > const &filename) const;

287 11 RootElement 0 4 392 26 TiXmlDocument::RootElement 0 2 109 110 207
/** Get the root element -- the only top level element -- of the document.
        In well formed XML, there should only be one. TinyXml is tolerant of
        multiple elements at the document level.
    */
107
TiXmlElement const *TiXmlDocument::RootElement(void) const;
TiXmlElement *TiXmlDocument::RootElement(void);

288 5 Error 0 4 392 20 TiXmlDocument::Error 0 1 111 330
/** If an error occurs, Error will be set to true. Also,
        - The ErrorId() will contain the integer identifier of the error (not generally useful)
        - The ErrorDesc() method will return the name of the error. (very useful)
        - The ErrorRow() and ErrorCol() will return the location of the error (if known)
    */
38
bool TiXmlDocument::Error(void) const;

289 9 ErrorDesc 0 4 392 24 TiXmlDocument::ErrorDesc 0 1 112 72
/// Contains a textual (english) description of the error if one occurs.
49
char const *TiXmlDocument::ErrorDesc(void) const;

290 7 ErrorId 0 4 392 22 TiXmlDocument::ErrorId 0 1 113 141
/** Generally, you probably want the error string ( ErrorDesc() ). But if you
        prefer the ErrorId, this function will fetch it.
    */
39
int TiXmlDocument::ErrorId(void) const;

291 8 ErrorRow 0 4 392 23 TiXmlDocument::ErrorRow 0 1 114 360
/** Returns the location (if known) of the error. The first column is column 1, 
        and the first row is row 1. A value of 0 means the row and column wasn't applicable
        (memory errors, for example, have no row/column) or the parser lost the error. (An
        error in the error reporting, in that case.)

        @sa SetTabSize, Row, Column
    */
40
int TiXmlDocument::ErrorRow(void) const;

292 8 ErrorCol 0 4 392 23 TiXmlDocument::ErrorCol 0 1 115 55
///< The column where the error occured. See ErrorRow()
40
int TiXmlDocument::ErrorCol(void) const;

293 10 SetTabSize 0 4 392 25 TiXmlDocument::SetTabSize 0 1 116 978
/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
        to report the correct values for row and column. It does not change the output
        or input in any way.
        
        By calling this method, with a tab size
        greater than 0, the row and column of each node and attribute is stored
        when the file is loaded. Very useful for tracking the DOM back in to
        the source file.

        The tab size is required for calculating the location of nodes. If not
        set, the default of 4 is used. The tabsize is set per document. Setting
        the tabsize to 0 disables row/column tracking.

        Note that row and column tracking is not supported when using operator>>.

        The tab size needs to be enabled before the parse or load. Correct usage:
        @verbatim
        TiXmlDocument doc;
        doc.SetTabSize( 8 );
        doc.Load( "myfile.xml" );
        @endverbatim

        @sa Row, Column
    */
45
void TiXmlDocument::SetTabSize(int _tabsize);

294 7 TabSize 0 4 392 22 TiXmlDocument::TabSize 0 1 117 0
39
int TiXmlDocument::TabSize(void) const;

295 10 ClearError 0 4 392 25 TiXmlDocument::ClearError 0 1 118 152
/** If you have handled the error, it can be reset with this call. The error
        state is automatically cleared if you Parse a new XML block.
    */
37
void TiXmlDocument::ClearError(void);

296 5 Print 0 4 392 20 TiXmlDocument::Print 0 1 119 84
/** Write the document to standard out using formatted printing ("pretty print"). */
38
void TiXmlDocument::Print(void) const;

297 8 SetError 0 4 392 23 TiXmlDocument::SetError 0 1 120 17
// [internal use]
117
void TiXmlDocument::SetError(int err, char const *errorLocation, TiXmlParsingData *prevData, TiXmlEncoding encoding);

298 12 TiXmlElement 0 4 393 26 TiXmlElement::TiXmlElement 0 3 121 122 123 55
/// Construct an element.

/// std::string constructor.
163
TiXmlElement::TiXmlElement(char const *in_value);
TiXmlElement::TiXmlElement(basic_string< char > const &_value);
TiXmlElement::TiXmlElement(TiXmlElement const &);

299 10 operator = 0 4 393 24 TiXmlElement::operator = 0 1 124 0
56
void TiXmlElement::operator =(TiXmlElement const &base);

300 9 Attribute 0 4 393 23 TiXmlElement::Attribute 0 2 125 126 695
/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
    */

/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
        If the attribute exists and can be converted to an integer,
        the integer value will be put in the return 'i', if 'i'
        is non-null.
    */

/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
        If the attribute exists and can be converted to an double,
        the double value will be put in the return 'd', if 'd'
        is non-null.
    */
499
char const *TiXmlElement::Attribute(char const *name) const;
char const *TiXmlElement::Attribute(char const *name, int *i) const;
char const *TiXmlElement::Attribute(char const *name, double *d) const;
basic_string< char > const *TiXmlElement::Attribute(basic_string< char > const &name) const;
basic_string< char > const *TiXmlElement::Attribute(basic_string< char > const &name, int *i) const;
basic_string< char > const *TiXmlElement::Attribute(basic_string< char > const &name, double *d) const;

301 17 QueryIntAttribute 0 4 393 31 TiXmlElement::QueryIntAttribute 0 0 385
/** QueryIntAttribute examines the attribute - it is an alternative to the
        Attribute() method with richer error checking.
        If the attribute is an integer, it is stored in 'value' and 
        the call returns TIXML_SUCCESS. If it is not
        an integer, it returns TIXML_WRONG_TYPE. If the attribute
        does not exist, then TIXML_NO_ATTRIBUTE is returned.
    */
163
int TiXmlElement::QueryIntAttribute(char const *name, int *_value) const;
int TiXmlElement::QueryIntAttribute(basic_string< char > const &name, int *_value) const;

302 20 QueryDoubleAttribute 0 4 393 34 TiXmlElement::QueryDoubleAttribute 0 0 74
/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
175
int TiXmlElement::QueryDoubleAttribute(char const *name, double *_value) const;
int TiXmlElement::QueryDoubleAttribute(basic_string< char > const &name, double *_value) const;

303 19 QueryFloatAttribute 0 4 393 33 TiXmlElement::QueryFloatAttribute 0 0 73
/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
77
int TiXmlElement::QueryFloatAttribute(char const *name, float *_value) const;

304 20 QueryStringAttribute 0 4 393 34 TiXmlElement::QueryStringAttribute 0 1 127 74
/// QueryStringAttribute examines the attribute - see QueryIntAttribute().
93
int TiXmlElement::QueryStringAttribute(char const *name, basic_string< char > *_value) const;

305 19 QueryValueAttribute 0 4 393 33 TiXmlElement::QueryValueAttribute 0 1 128 0
110
int TiXmlElement::QueryValueAttribute(basic_string< char > const &name, basic_string< char > *outValue) const;

306 12 SetAttribute 0 4 393 26 TiXmlElement::SetAttribute 0 4 129 130 131 132 331
/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */

/// STL std::string form.

///< STL std::string form.

/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */
314
void TiXmlElement::SetAttribute(char const *name, char const *_value);
void TiXmlElement::SetAttribute(basic_string< char > const &name, basic_string< char > const &_value);
void TiXmlElement::SetAttribute(basic_string< char > const &name, int _value);
void TiXmlElement::SetAttribute(char const *name, int value);

307 18 SetDoubleAttribute 0 4 393 32 TiXmlElement::SetDoubleAttribute 0 2 133 134 165
///< STL std::string form.

/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */
157
void TiXmlElement::SetDoubleAttribute(basic_string< char > const &name, double value);
void TiXmlElement::SetDoubleAttribute(char const *name, double value);

308 15 RemoveAttribute 0 4 393 29 TiXmlElement::RemoveAttribute 0 2 135 136 80
/** Deletes an attribute with the given name.
    */

///< STL std::string form.
123
void TiXmlElement::RemoveAttribute(char const *name);
void TiXmlElement::RemoveAttribute(basic_string< char > const &name);

309 14 FirstAttribute 0 4 393 28 TiXmlElement::FirstAttribute 0 2 137 138 98
///< Access the first attribute in this element.

///< Access the first attribute in this element.
115
TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const;
TiXmlAttribute *TiXmlElement::FirstAttribute(void);

310 13 LastAttribute 0 4 393 27 TiXmlElement::LastAttribute 0 2 139 140 96
///< Access the last attribute in this element.

///< Access the last attribute in this element.
113
TiXmlAttribute const *TiXmlElement::LastAttribute(void) const;
TiXmlAttribute *TiXmlElement::LastAttribute(void);

311 7 GetText 0 4 393 21 TiXmlElement::GetText 0 1 141 1291
/** Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.
    
        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement->GetText();
        @endverbatim

        'str' will be a pointer to "This is text". 
        
        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo> 
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo> 
        @endverbatim
        GetText() will return "This is ".

        WARNING: GetText() accesses a child node - don't become confused with the 
                 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
                 safe type casts on the referenced node.
    */
46
char const *TiXmlElement::GetText(void) const;

312 15 read_xml_stream 0 1 0 15 read_xml_stream 0 1 230 293
////////////////////////////////////////////////////////////////////
//     Function: read_xml_stream
//  Description: Reads an XML document from the indicated stream.
//               Returns the document, or NULL on error.
////////////////////////////////////////////////////////////////////
44
TiXmlDocument *read_xml_stream(istream &in);

313 16 write_xml_stream 0 1 0 16 write_xml_stream 0 1 231 0
56
void write_xml_stream(ostream &out, TiXmlDocument *doc);

314 9 print_xml 0 1 0 9 print_xml 0 1 232 0
33
void print_xml(TiXmlNode *xnode);

315 17 print_xml_to_file 0 1 0 17 print_xml_to_file 0 1 233 0
67
void print_xml_to_file(Filename const &filename, TiXmlNode *xnode);

316 23 get_TIXML_MAJOR_VERSION 0 16 0 23 get_TIXML_MAJOR_VERSION 0 1 234 41
getter for int const TIXML_MAJOR_VERSION;
34
int get_TIXML_MAJOR_VERSION(void);

317 23 get_TIXML_MINOR_VERSION 0 16 0 23 get_TIXML_MINOR_VERSION 0 1 235 41
getter for int const TIXML_MINOR_VERSION;
34
int get_TIXML_MINOR_VERSION(void);

318 23 get_TIXML_PATCH_VERSION 0 16 0 23 get_TIXML_PATCH_VERSION 0 1 236 41
getter for int const TIXML_PATCH_VERSION;
34
int get_TIXML_PATCH_VERSION(void);

319 12 ~TiXmlCursor 0 4 395 25 TiXmlCursor::~TiXmlCursor 0 0 0
32
TiXmlCursor::~TiXmlCursor(void);

320 13 ~TiXmlVisitor 0 6 396 27 TiXmlVisitor::~TiXmlVisitor 0 0 0
42
virtual TiXmlVisitor::~TiXmlVisitor(void);

321 10 VisitEnter 0 6 396 24 TiXmlVisitor::VisitEnter 0 2 142 143 27
/*doc*/

/*firstAttribute*/
146
virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &);
virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *);

322 9 VisitExit 0 6 396 23 TiXmlVisitor::VisitExit 0 2 144 145 20
/*doc*/

/*element*/
120
virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &);
virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &);

323 5 Visit 0 6 396 19 TiXmlVisitor::Visit 0 4 146 147 148 149 51
/*declaration*/

/*text*/

/*comment*/

/*unknown*/
224
virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &);
virtual bool TiXmlVisitor::Visit(TiXmlText const &);
virtual bool TiXmlVisitor::Visit(TiXmlComment const &);
virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &);

324 26 get_TIXML_DEFAULT_ENCODING 0 16 0 26 get_TIXML_DEFAULT_ENCODING 0 1 237 54
getter for TiXmlEncoding const TIXML_DEFAULT_ENCODING;
47
TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void);

325 14 TiXmlAttribute 0 4 398 30 TiXmlAttribute::TiXmlAttribute 0 3 150 151 152 114
/// Construct an empty attribute.

/// std::string constructor.

/// Construct an attribute with a name and value.
211
TiXmlAttribute::TiXmlAttribute(void);
TiXmlAttribute::TiXmlAttribute(basic_string< char > const &_name, basic_string< char > const &_value);
TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value);

326 4 Name 0 4 398 20 TiXmlAttribute::Name 0 1 153 39
///< Return the name of this attribute.
45
char const *TiXmlAttribute::Name(void) const;

327 5 Value 0 4 398 21 TiXmlAttribute::Value 0 1 154 40
///< Return the value of this attribute.
46
char const *TiXmlAttribute::Value(void) const;

328 8 ValueStr 0 4 398 24 TiXmlAttribute::ValueStr 0 1 155 40
///< Return the value of this attribute.
65
basic_string< char > const &TiXmlAttribute::ValueStr(void) const;

329 8 IntValue 0 4 398 24 TiXmlAttribute::IntValue 0 1 156 65
///< Return the value of this attribute, converted to an integer.
41
int TiXmlAttribute::IntValue(void) const;

330 11 DoubleValue 0 4 398 27 TiXmlAttribute::DoubleValue 0 1 157 63
///< Return the value of this attribute, converted to a double.
47
double TiXmlAttribute::DoubleValue(void) const;

331 8 NameTStr 0 4 398 24 TiXmlAttribute::NameTStr 0 1 158 40
// Get the tinyxml string representation
65
basic_string< char > const &TiXmlAttribute::NameTStr(void) const;

332 13 QueryIntValue 0 4 398 29 TiXmlAttribute::QueryIntValue 0 0 441
/** QueryIntValue examines the value string. It is an alternative to the
        IntValue() method with richer error checking.
        If the value is an integer, it is stored in 'value' and 
        the call returns TIXML_SUCCESS. If it is not
        an integer, it returns TIXML_WRONG_TYPE.

        A specialized but useful call. Note that for success it returns 0,
        which is the opposite of almost all other TinyXml calls.
    */
53
int TiXmlAttribute::QueryIntValue(int *_value) const;

333 16 QueryDoubleValue 0 4 398 32 TiXmlAttribute::QueryDoubleValue 0 0 68
/// QueryDoubleValue examines the value string. See QueryIntValue().
59
int TiXmlAttribute::QueryDoubleValue(double *_value) const;

334 7 SetName 0 4 398 23 TiXmlAttribute::SetName 0 2 159 160 63
///< Set the name of this attribute.

/// STL std::string form.
113
void TiXmlAttribute::SetName(char const *_name);
void TiXmlAttribute::SetName(basic_string< char > const &_name);

335 8 SetValue 0 4 398 24 TiXmlAttribute::SetValue 0 2 161 162 46
///< Set the value.

/// STL std::string form.
117
void TiXmlAttribute::SetValue(char const *_value);
void TiXmlAttribute::SetValue(basic_string< char > const &_value);

336 11 SetIntValue 0 4 398 27 TiXmlAttribute::SetIntValue 0 1 163 35
///< Set the value from an integer.
45
void TiXmlAttribute::SetIntValue(int _value);

337 14 SetDoubleValue 0 4 398 30 TiXmlAttribute::SetDoubleValue 0 1 164 33
///< Set the value from a double.
51
void TiXmlAttribute::SetDoubleValue(double _value);

338 4 Next 0 4 398 20 TiXmlAttribute::Next 0 2 165 166 67
/// Get the next sibling attribute in the DOM. Returns null at end.
99
TiXmlAttribute const *TiXmlAttribute::Next(void) const;
TiXmlAttribute *TiXmlAttribute::Next(void);

339 8 Previous 0 4 398 24 TiXmlAttribute::Previous 0 2 167 168 77
/// Get the previous sibling attribute in the DOM. Returns null at beginning.
107
TiXmlAttribute const *TiXmlAttribute::Previous(void) const;
TiXmlAttribute *TiXmlAttribute::Previous(void);

340 11 operator == 0 4 398 27 TiXmlAttribute::operator == 0 1 169 0
66
bool TiXmlAttribute::operator ==(TiXmlAttribute const &rhs) const;

341 10 operator < 0 4 398 26 TiXmlAttribute::operator < 0 1 170 0
65
bool TiXmlAttribute::operator <(TiXmlAttribute const &rhs) const;

342 10 operator > 0 4 398 26 TiXmlAttribute::operator > 0 1 171 0
65
bool TiXmlAttribute::operator >(TiXmlAttribute const &rhs) const;

343 5 Print 0 4 398 21 TiXmlAttribute::Print 0 1 172 9
/*depth*/
84
void TiXmlAttribute::Print(FILE *cfile, int depth, basic_string< char > *str) const;

344 11 SetDocument 0 4 398 27 TiXmlAttribute::SetDocument 0 1 173 81
// [internal use]
// Set the document pointer so the attribute can report errors.
53
void TiXmlAttribute::SetDocument(TiXmlDocument *doc);

345 15 ~TiXmlAttribute 0 4 398 31 TiXmlAttribute::~TiXmlAttribute 0 0 0
38
TiXmlAttribute::~TiXmlAttribute(void);

346 17 TiXmlAttributeSet 0 4 399 36 TiXmlAttributeSet::TiXmlAttributeSet 0 1 174 0
43
TiXmlAttributeSet::TiXmlAttributeSet(void);

347 18 ~TiXmlAttributeSet 0 4 399 37 TiXmlAttributeSet::~TiXmlAttributeSet 0 0 0
44
TiXmlAttributeSet::~TiXmlAttributeSet(void);

348 3 Add 0 4 399 22 TiXmlAttributeSet::Add 0 1 175 0
55
void TiXmlAttributeSet::Add(TiXmlAttribute *attribute);

349 6 Remove 0 4 399 25 TiXmlAttributeSet::Remove 0 1 176 0
58
void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute);

350 5 First 0 4 399 24 TiXmlAttributeSet::First 0 2 177 178 0
107
TiXmlAttribute const *TiXmlAttributeSet::First(void) const;
TiXmlAttribute *TiXmlAttributeSet::First(void);

351 4 Last 0 4 399 23 TiXmlAttributeSet::Last 0 2 179 180 0
105
TiXmlAttribute const *TiXmlAttributeSet::Last(void) const;
TiXmlAttribute *TiXmlAttributeSet::Last(void);

352 4 Find 0 4 399 23 TiXmlAttributeSet::Find 0 2 181 182 0
147
TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const;
TiXmlAttribute *TiXmlAttributeSet::Find(basic_string< char > const &_name) const;

353 12 FindOrCreate 0 4 399 31 TiXmlAttributeSet::FindOrCreate 0 2 183 184 0
151
TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name);
TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(basic_string< char > const &_name);

354 12 TiXmlComment 0 4 400 26 TiXmlComment::TiXmlComment 0 3 185 186 187 68
/// Constructs an empty comment.

/// Construct a comment from text.
131
TiXmlComment::TiXmlComment(void);
TiXmlComment::TiXmlComment(char const *_value);
TiXmlComment::TiXmlComment(TiXmlComment const &);

355 10 operator = 0 4 400 24 TiXmlComment::operator = 0 1 188 0
56
void TiXmlComment::operator =(TiXmlComment const &base);

356 9 TiXmlText 0 4 401 20 TiXmlText::TiXmlText 0 3 189 190 191 211
/** Constructor for text element. By default, it is treated as 
        normal, encoded text. If you want it be output as a CDATA text
        element, set the parameter _cdata to 'true'
    */

/// Constructor.
150
TiXmlText::TiXmlText(char const *initValue);
TiXmlText::TiXmlText(basic_string< char > const &initValue);
TiXmlText::TiXmlText(TiXmlText const &copy);

357 10 operator = 0 4 401 21 TiXmlText::operator = 0 1 192 0
50
void TiXmlText::operator =(TiXmlText const &base);

358 5 CDATA 0 4 401 16 TiXmlText::CDATA 0 1 193 63
/// Queries whether this represents text using a CDATA section.
34
bool TiXmlText::CDATA(void) const;

359 8 SetCDATA 0 4 401 19 TiXmlText::SetCDATA 0 1 194 51
/// Turns on or off a CDATA representation of text.
38
void TiXmlText::SetCDATA(bool _cdata);

360 12 TiXmlUnknown 0 4 402 26 TiXmlUnknown::TiXmlUnknown 0 2 195 196 0
87
TiXmlUnknown::TiXmlUnknown(void);
TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy);

361 10 operator = 0 4 402 24 TiXmlUnknown::operator = 0 1 197 0
56
void TiXmlUnknown::operator =(TiXmlUnknown const &copy);

362 11 TiXmlHandle 0 4 403 24 TiXmlHandle::TiXmlHandle 0 2 198 199 111
/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.

/// Copy constructor
93
TiXmlHandle::TiXmlHandle(TiXmlNode *_node);
TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref);

363 10 operator = 0 4 403 23 TiXmlHandle::operator = 0 1 200 0
60
TiXmlHandle TiXmlHandle::operator =(TiXmlHandle const &ref);

364 10 FirstChild 0 4 403 23 TiXmlHandle::FirstChild 0 3 201 202 203 110
/// Return a handle to the first child node.

/// Return a handle to the first child node with the given name.
189
TiXmlHandle TiXmlHandle::FirstChild(void) const;
TiXmlHandle TiXmlHandle::FirstChild(char const *value) const;
TiXmlHandle TiXmlHandle::FirstChild(basic_string< char > const &_value) const;

365 17 FirstChildElement 0 4 403 30 TiXmlHandle::FirstChildElement 0 3 204 205 206 116
/// Return a handle to the first child element.

/// Return a handle to the first child element with the given name.
210
TiXmlHandle TiXmlHandle::FirstChildElement(void) const;
TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const;
TiXmlHandle TiXmlHandle::FirstChildElement(basic_string< char > const &_value) const;

366 5 Child 0 4 403 18 TiXmlHandle::Child 0 3 207 208 209 218
/** Return a handle to the "index" child with the given name. 
        The first child is 0, the second 1, etc.
    */

/** Return a handle to the "index" child. 
        The first child is 0, the second 1, etc.
    */
201
TiXmlHandle TiXmlHandle::Child(char const *value, int index) const;
TiXmlHandle TiXmlHandle::Child(int index) const;
TiXmlHandle TiXmlHandle::Child(basic_string< char > const &_value, int index) const;

367 12 ChildElement 0 4 403 25 TiXmlHandle::ChildElement 0 3 210 211 212 408
/** Return a handle to the "index" child element with the given name. 
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */

/** Return a handle to the "index" child element. 
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */
222
TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const;
TiXmlHandle TiXmlHandle::ChildElement(int index) const;
TiXmlHandle TiXmlHandle::ChildElement(basic_string< char > const &_value, int index) const;

368 6 ToNode 0 4 403 19 TiXmlHandle::ToNode 0 1 213 66
/** Return the handle as a TiXmlNode. This may return null.
    */
43
TiXmlNode *TiXmlHandle::ToNode(void) const;

369 9 ToElement 0 4 403 22 TiXmlHandle::ToElement 0 1 214 69
/** Return the handle as a TiXmlElement. This may return null.
    */
49
TiXmlElement *TiXmlHandle::ToElement(void) const;

370 6 ToText 0 4 403 19 TiXmlHandle::ToText 0 1 215 66
/** Return the handle as a TiXmlText. This may return null.
    */
43
TiXmlText *TiXmlHandle::ToText(void) const;

371 9 ToUnknown 0 4 403 22 TiXmlHandle::ToUnknown 0 1 216 69
/** Return the handle as a TiXmlUnknown. This may return null.
    */
49
TiXmlUnknown *TiXmlHandle::ToUnknown(void) const;

372 4 Node 0 4 403 17 TiXmlHandle::Node 0 1 217 99
/** @deprecated use ToNode. 
        Return the handle as a TiXmlNode. This may return null.
    */
41
TiXmlNode *TiXmlHandle::Node(void) const;

373 7 Element 0 4 403 20 TiXmlHandle::Element 0 1 218 105
/** @deprecated use ToElement. 
        Return the handle as a TiXmlElement. This may return null.
    */
47
TiXmlElement *TiXmlHandle::Element(void) const;

374 4 Text 0 4 403 17 TiXmlHandle::Text 0 1 219 99
/** @deprecated use ToText()
        Return the handle as a TiXmlText. This may return null.
    */
41
TiXmlText *TiXmlHandle::Text(void) const;

375 7 Unknown 0 4 403 20 TiXmlHandle::Unknown 0 1 220 105
/** @deprecated use ToUnknown()
        Return the handle as a TiXmlUnknown. This may return null.
    */
47
TiXmlUnknown *TiXmlHandle::Unknown(void) const;

376 12 ~TiXmlHandle 0 4 403 25 TiXmlHandle::~TiXmlHandle 0 0 0
32
TiXmlHandle::~TiXmlHandle(void);

377 12 TiXmlPrinter 0 4 404 26 TiXmlPrinter::TiXmlPrinter 0 1 221 0
33
TiXmlPrinter::TiXmlPrinter(void);

378 9 SetIndent 0 4 404 23 TiXmlPrinter::SetIndent 0 1 222 148
/** Set the indent characters for printing. By default 4 spaces
        but tab (\t) is also useful, or null/empty string for no indentation.
    */
50
void TiXmlPrinter::SetIndent(char const *_indent);

379 6 Indent 0 4 404 20 TiXmlPrinter::Indent 0 1 223 31
/// Query the indention string.
39
char const *TiXmlPrinter::Indent(void);

380 12 SetLineBreak 0 4 404 26 TiXmlPrinter::SetLineBreak 0 1 224 195
/** Set the line breaking string. By default set to newline (\n). 
        Some operating systems prefer other characters, or can be
        set to the null/empty string for no indenation.
    */
56
void TiXmlPrinter::SetLineBreak(char const *_lineBreak);

381 9 LineBreak 0 4 404 23 TiXmlPrinter::LineBreak 0 1 225 43
/// Query the current line breaking string.
42
char const *TiXmlPrinter::LineBreak(void);

382 17 SetStreamPrinting 0 4 404 31 TiXmlPrinter::SetStreamPrinting 0 1 226 163
/** Switch over to "stream printing" which is the most dense formatting without 
        linebreaks. Common when the XML is needed for network transmission.
    */
43
void TiXmlPrinter::SetStreamPrinting(void);

383 4 CStr 0 4 404 18 TiXmlPrinter::CStr 0 1 227 22
/// Return the result.
37
char const *TiXmlPrinter::CStr(void);

384 4 Size 0 4 404 18 TiXmlPrinter::Size 0 1 228 43
/// Return the length of the result string.
38
unsigned int TiXmlPrinter::Size(void);

385 3 Str 0 4 404 17 TiXmlPrinter::Str 0 1 229 22
/// Return the result.
52
basic_string< char > const &TiXmlPrinter::Str(void);

386 13 ~TiXmlPrinter 0 4 404 27 TiXmlPrinter::~TiXmlPrinter 0 0 0
34
TiXmlPrinter::~TiXmlPrinter(void);

237
1 14 Dtool_uZHmU8sh 0 4 3 409 0 14 Dtool_uZHmU8sh 356 /** All TinyXml classes can print themselves to a filestream
        or the string class (TiXmlString in non-STL mode, std::string
        in STL mode.) Either or both cfile and str can be null.
        
        This is a formatted print, and will insert 
        tabs and newlines.
        
        (For an unformatted stream, use the << operator.)
    */ 3 4 this 3 405  5 cfile 1 407  5 depth 1 394  
2 14 Dtool_uZHmrhC_ 0 4 4 409 0 14 Dtool_uZHmrhC_ 351 /** The world does not agree on whether white space should be kept or
        not. In order to make everyone happy, these global, static functions
        are provided to set whether or not TinyXml will condense all white space
        into a single space or not. The default is to condense. Note changing this
        value is not thread safe.
    */ 1 8 condense 1 410  
3 14 Dtool_uZHm83bR 0 6 5 410 0 14 Dtool_uZHm83bR 43 /// Return the current white space setting. 0 
4 14 Dtool_uZHmTG7N 0 6 6 394 0 14 Dtool_uZHmTG7N 944 /** Return the position, in the original source file, of this node or attribute.
        The row and column are 1-based. (That is the first row and first column is
        1,1). If the returns values are 0 or less, then the parser does not have
        a row and column value.

        Generally, the row and column value will be set when the TiXmlDocument::Load(),
        TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
        when the DOM was created from operator>>.

        The values reflect the initial load. Once the DOM is modified programmatically
        (by adding or changing nodes and attributes) the new values will NOT update to
        reflect changes in the document.

        There is a minor performance cost to computing the row and column. Computation
        can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

        @sa TiXmlDocument::SetTabSize()
    */ 1 4 this 3 405  
5 14 Dtool_uZHmf2Wl 0 6 7 394 0 14 Dtool_uZHmf2Wl 14 ///< See Row() 1 4 this 3 405  
6 14 Dtool_uZHm7USY 0 4 9 409 0 14 Dtool_uZHm7USY 42 ///< Get a pointer to arbitrary user data. 1 4 this 3 411  
7 14 Dtool_uZHm7Eql 0 4 9 409 0 14 Dtool_uZHm7Eql 42 ///< Get a pointer to arbitrary user data. 1 4 this 3 405  
8 14 Dtool_uZHmv_FV 0 6 10 412 0 14 Dtool_uZHmv_FV 0 4 4 this 3 411  1 p 1 412  4 data 1 413  8 encoding 1 397  
9 14 Dtool_uZHmFaYE 0 4 11 409 0 14 Dtool_uZHmFaYE 146 /** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
        or they will be transformed into entities!
    */ 2 3 str 1 412  3 out 1 415  
10 14 Dtool_uZHmQ6Mv 0 7 45 417 238 14 Dtool_uZHmQ6Mv 35 /// Construct an empty declaration. 0 
11 14 Dtool_uZHmqGgp 0 7 45 417 238 14 Dtool_uZHmqGgp 0 1 4 copy 1 418  
12 14 Dtool_uZHm0Sq_ 0 7 45 417 238 14 Dtool_uZHm0Sq_ 16 /// Constructor. 3 8 _version 1 412  9 _encoding 1 412  11 _standalone 1 412  
13 14 Dtool_uZHmW6tS 0 7 45 417 238 14 Dtool_uZHmW6tS 14 /// Construct. 3 8 _version 1 412  9 _encoding 1 412  11 _standalone 1 412  
14 14 Dtool_uZHmiNs6 0 6 46 417 0 14 Dtool_uZHmiNs6 0 2 4 this 3 417  4 copy 1 418  
15 14 Dtool_uZHm7KcU 0 6 47 412 0 14 Dtool_uZHm7KcU 59 /// Version. Will return an empty string if none was found. 1 4 this 3 418  
16 14 Dtool_uZHmhrcW 0 6 48 412 0 14 Dtool_uZHmhrcW 60 /// Encoding. Will return an empty string if none was found. 1 4 this 3 418  
17 14 Dtool_uZHmY7Dr 0 6 49 412 0 14 Dtool_uZHmY7Dr 34 /// Is this a standalone document? 1 4 this 3 418  
18 14 Dtool_uZHm10d1 0 4 50 409 0 14 Dtool_uZHm10d1 43 // Print this declaration to a FILE stream. 4 4 this 3 418  5 cfile 1 407  5 depth 1 394  3 str 1 415  
19 14 Dtool_uZHmfesc 0 6 16 412 0 14 Dtool_uZHmfesc 368 /** The meaning of 'value' changes for the specific type of
        TiXmlNode.
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim

        The subclasses will wrap this function.
    */ 1 4 this 3 420  
20 14 Dtool_uZHmP2AW 0 6 17 412 0 14 Dtool_uZHmP2AW 153 /** Return Value() as a std::string. If you only use STL,
        this is more efficient than calling Value().
        Only available in STL mode.
    */ 1 4 this 3 420  
21 14 Dtool_uZHmPIk_ 0 6 18 412 0 14 Dtool_uZHmPIk_ 0 1 4 this 3 420  
22 14 Dtool_uZHmE3Gz 0 4 19 409 0 14 Dtool_uZHmE3Gz 25 /// STL std::string form. 2 4 this 3 422  6 _value 1 412  
23 14 Dtool_uZHmKcc6 0 4 19 409 0 14 Dtool_uZHmKcc6 287 /** Changes the value of the node. Defined as:
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim
    */ 2 4 this 3 422  6 _value 1 412  
24 14 Dtool_uZHmTkvr 0 4 20 409 0 14 Dtool_uZHmTkvr 65 /// Delete all the children of this node. Does not affect 'this'. 1 4 this 3 422  
25 14 Dtool_uZHm0H_S 0 6 21 422 0 14 Dtool_uZHm0H_S 24 /// One step up the DOM. 1 4 this 3 422  
26 14 Dtool_uZHmymp5 0 6 21 420 0 14 Dtool_uZHmymp5 0 1 4 this 3 420  
27 14 Dtool_uZHmLBQb 0 6 22 422 0 14 Dtool_uZHmLBQb 73 ///< The first child of this node. Will be null if there are no children. 1 4 this 3 422  
28 14 Dtool_uZHm_qqp 0 6 22 420 0 14 Dtool_uZHm_qqp 73 ///< The first child of this node. Will be null if there are no children. 1 4 this 3 420  
29 14 Dtool_uZHm8LJk 0 6 22 422 0 14 Dtool_uZHm8LJk 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
30 14 Dtool_uZHm_40K 0 6 22 420 0 14 Dtool_uZHm_40K 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
31 14 Dtool_uZHmk91F 0 6 22 422 0 14 Dtool_uZHmk91F 176 ///< The first child of this node with the matching 'value'. Will be null if none found.
/// The first child of this node with the matching 'value'. Will be null if none found. 2 4 this 3 422  6 _value 1 412  
32 14 Dtool_uZHmqzn1 0 6 22 420 0 14 Dtool_uZHmqzn1 0 2 4 this 3 420  5 value 1 412  
33 14 Dtool_uZHmS6W4 0 6 23 422 0 14 Dtool_uZHmS6W4 71 /// The last child of this node. Will be null if there are no children. 1 4 this 3 422  
34 14 Dtool_uZHmy0zg 0 6 23 420 0 14 Dtool_uZHmy0zg 71 /// The last child of this node. Will be null if there are no children. 1 4 this 3 420  
35 14 Dtool_uZHmgqkQ 0 6 23 422 0 14 Dtool_uZHmgqkQ 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
36 14 Dtool_uZHmsOvX 0 6 23 420 0 14 Dtool_uZHmsOvX 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
37 14 Dtool_uZHmr7q7 0 6 23 422 0 14 Dtool_uZHmr7q7 88 /// The last child of this node matching 'value'. Will be null if there are no children. 2 4 this 3 422  6 _value 1 412  
38 14 Dtool_uZHmwPHx 0 6 23 420 0 14 Dtool_uZHmwPHx 88 /// The last child of this node matching 'value'. Will be null if there are no children. 2 4 this 3 420  5 value 1 412  
39 14 Dtool_uZHmpGKV 0 6 24 422 0 14 Dtool_uZHmpGKV 0 2 4 this 3 422  8 previous 1 420  
40 14 Dtool_uZHmVdbU 0 6 24 420 0 14 Dtool_uZHmVdbU 607 /** An alternate way to walk the children of a node.
        One way to iterate over nodes is:
        @verbatim
            for( child = parent->FirstChild(); child; child = child->NextSibling() )
        @endverbatim

        IterateChildren does the same thing with the syntax:
        @verbatim
            child = 0;
            while( child = parent->IterateChildren( child ) )
        @endverbatim

        IterateChildren takes the previous child as input and finds
        the next one. If the previous child is null, it returns the
        first. IterateChildren will return null when done.
    */ 2 4 this 3 420  8 previous 1 420  
41 14 Dtool_uZHmB47B 0 6 24 422 0 14 Dtool_uZHmB47B 26 ///< STL std::string form. 3 4 this 3 422  6 _value 1 412  8 previous 1 420  
42 14 Dtool_uZHmA5no 0 6 24 420 0 14 Dtool_uZHmA5no 26 ///< STL std::string form. 3 4 this 3 420  6 _value 1 412  8 previous 1 420  
43 14 Dtool_uZHmhSgs 0 6 24 422 0 14 Dtool_uZHmhSgs 0 3 4 this 3 422  6 _value 1 412  8 previous 1 420  
44 14 Dtool_uZHm9QSc 0 6 24 420 0 14 Dtool_uZHm9QSc 82 /// This flavor of IterateChildren searches for children with a particular 'value' 3 4 this 3 420  5 value 1 412  8 previous 1 420  
45 14 Dtool_uZHm97r4 0 6 25 422 0 14 Dtool_uZHm97r4 148 /** Add a new node related to this. Adds a child past the LastChild.
        Returns a pointer to the new object or NULL if an error occured.
    */ 2 4 this 3 422  7 addThis 1 420  
46 14 Dtool_uZHmBJU3 0 6 26 422 0 14 Dtool_uZHmBJU3 156 /** Add a new node related to this. Adds a child before the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 422  10 beforeThis 1 422  7 addThis 1 420  
47 14 Dtool_uZHmsnk0 0 6 27 422 0 14 Dtool_uZHmsnk0 155 /** Add a new node related to this. Adds a child after the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 422  9 afterThis 1 422  7 addThis 1 420  
48 14 Dtool_uZHmbgu6 0 6 28 422 0 14 Dtool_uZHmbgu6 113 /** Replace a child of this node.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 422  11 replaceThis 1 422  8 withThis 1 420  
49 14 Dtool_uZHmwYYG 0 6 29 410 0 14 Dtool_uZHmwYYG 32 /// Delete a child of this node. 2 4 this 3 422  10 removeThis 1 422  
50 14 Dtool_uZHmjr_b 0 6 30 422 0 14 Dtool_uZHmjr_b 0 1 4 this 3 422  
51 14 Dtool_uZHmaVz4 0 6 30 420 0 14 Dtool_uZHmaVz4 31 /// Navigate to a sibling node. 1 4 this 3 420  
52 14 Dtool_uZHm_J3t 0 6 30 422 0 14 Dtool_uZHm_J3t 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
53 14 Dtool_uZHm_xN7 0 6 30 420 0 14 Dtool_uZHm_xN7 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
54 14 Dtool_uZHmp_Kx 0 6 30 422 0 14 Dtool_uZHmp_Kx 0 2 4 this 3 422  5 _prev 1 412  
55 14 Dtool_uZHmYtxQ 0 6 30 420 0 14 Dtool_uZHmYtxQ 31 /// Navigate to a sibling node. 2 4 this 3 420  6 param0 0 412  
56 14 Dtool_uZHmYsOr 0 6 31 422 0 14 Dtool_uZHmYsOr 0 1 4 this 3 422  
57 14 Dtool_uZHmfqm4 0 6 31 420 0 14 Dtool_uZHmfqm4 31 /// Navigate to a sibling node. 1 4 this 3 420  
58 14 Dtool_uZHm9eFK 0 6 31 422 0 14 Dtool_uZHm9eFK 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
59 14 Dtool_uZHmt0Dg 0 6 31 420 0 14 Dtool_uZHmt0Dg 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
60 14 Dtool_uZHmBrz_ 0 6 31 422 0 14 Dtool_uZHmBrz_ 0 2 4 this 3 422  5 _next 1 412  
61 14 Dtool_uZHmX644 0 6 31 420 0 14 Dtool_uZHmX644 54 /// Navigate to a sibling node with the given 'value'. 2 4 this 3 420  6 param0 0 412  
62 14 Dtool_uZHm9UmW 0 6 32 423 0 14 Dtool_uZHm9UmW 0 1 4 this 3 422  
63 14 Dtool_uZHmfsoT 0 6 32 424 0 14 Dtool_uZHmfsoT 181 /** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */ 1 4 this 3 420  
64 14 Dtool_uZHmD9kp 0 6 32 423 0 14 Dtool_uZHmD9kp 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
65 14 Dtool_uZHmDad6 0 6 32 424 0 14 Dtool_uZHmDad6 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
66 14 Dtool_uZHmfE9G 0 6 32 423 0 14 Dtool_uZHmfE9G 0 2 4 this 3 422  5 _next 1 412  
67 14 Dtool_uZHmbpot 0 6 32 424 0 14 Dtool_uZHmbpot 181 /** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */ 2 4 this 3 420  6 param0 0 412  
68 14 Dtool_uZHmqmks 0 6 33 423 0 14 Dtool_uZHmqmks 0 1 4 this 3 422  
69 14 Dtool_uZHmMeeE 0 6 33 424 0 14 Dtool_uZHmMeeE 49 /// Convenience function to get through elements. 1 4 this 3 420  
70 14 Dtool_uZHm18Hp 0 6 33 423 0 14 Dtool_uZHm18Hp 26 ///< STL std::string form. 2 4 this 3 422  6 _value 1 412  
71 14 Dtool_uZHm4Hon 0 6 33 424 0 14 Dtool_uZHm4Hon 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 412  
72 14 Dtool_uZHmmvES 0 6 33 423 0 14 Dtool_uZHmmvES 0 2 4 this 3 422  6 _value 1 412  
73 14 Dtool_uZHmaIQZ 0 6 33 424 0 14 Dtool_uZHmaIQZ 49 /// Convenience function to get through elements. 2 4 this 3 420  6 _value 1 412  
74 14 Dtool_uZHm5CBc 0 6 34 394 0 14 Dtool_uZHm5CBc 195 /** Query the type (as an enumerated value, above) of this node.
        The possible types are: DOCUMENT, ELEMENT, COMMENT,
                                UNKNOWN, TEXT, and DECLARATION.
    */ 1 4 this 3 420  
75 14 Dtool_uZHmkD8Q 0 6 35 426 0 14 Dtool_uZHmkD8Q 0 1 4 this 3 422  
76 14 Dtool_uZHm_JTe 0 6 35 427 0 14 Dtool_uZHm_JTe 106 /** Return a pointer to the Document this node lives in.
        Returns null if not in a document.
    */ 1 4 this 3 420  
77 14 Dtool_uZHm_e4U 0 6 36 410 0 14 Dtool_uZHm_e4U 46 /// Returns true if this node has no children. 1 4 this 3 420  
78 14 Dtool_uZHm1zjY 0 6 37 426 0 14 Dtool_uZHm1zjY 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
79 14 Dtool_uZHmYh9m 0 6 37 427 0 14 Dtool_uZHmYh9m 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
80 14 Dtool_uZHmFwOr 0 6 38 423 0 14 Dtool_uZHmFwOr 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
81 14 Dtool_uZHm4NsT 0 6 38 424 0 14 Dtool_uZHm4NsT 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
82 14 Dtool_uZHm10e1 0 6 39 429 0 14 Dtool_uZHm10e1 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
83 14 Dtool_uZHmof6d 0 6 39 430 0 14 Dtool_uZHmof6d 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
84 14 Dtool_uZHmFrLi 0 6 40 432 0 14 Dtool_uZHmFrLi 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
85 14 Dtool_uZHm_snK 0 6 40 433 0 14 Dtool_uZHm_snK 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
86 14 Dtool_uZHmBUz6 0 6 41 435 0 14 Dtool_uZHmBUz6 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
87 14 Dtool_uZHmFDfh 0 6 41 436 0 14 Dtool_uZHmFDfh 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
88 14 Dtool_uZHm8f77 0 6 42 417 0 14 Dtool_uZHm8f77 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 422  
89 14 Dtool_uZHmPFb6 0 6 42 418 0 14 Dtool_uZHmPFb6 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
90 14 Dtool_uZHm1v_D 0 6 43 422 0 14 Dtool_uZHm1v_D 115 /** Create an exact duplicate of this node and return it. The memory must be deleted
        by the caller. 
    */ 1 4 this 3 420  
91 14 Dtool_uZHm9aC0 0 6 44 410 0 14 Dtool_uZHm9aC0 827 /** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
        XML tree will be conditionally visited and the host will be called back
        via the TiXmlVisitor interface.

        This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
        the XML for the callbacks, so the performance of TinyXML is unchanged by using this
        interface versus any other.)

        The interface has been based on ideas from:

        - http://www.saxproject.org/
        - http://c2.com/cgi/wiki?HierarchicalVisitorPattern 

        Which are both good references for "visiting".

        An example of using Accept():
        @verbatim
        TiXmlPrinter printer;
        tinyxmlDoc.Accept( &printer );
        const char* xmlcstr = printer.CStr();
        @endverbatim
    */ 2 4 this 3 420  7 visitor 1 438  
92 14 Dtool_uZHmy7nW 0 7 52 426 238 14 Dtool_uZHmy7nW 47 /// Create an empty document, that has no name. 0 
93 14 Dtool_uZHm1W_n 0 7 52 426 238 14 Dtool_uZHm1W_n 0 1 4 copy 1 427  
94 14 Dtool_uZHmEgJT 0 7 52 426 238 14 Dtool_uZHmEgJT 16 /// Constructor. 1 12 documentName 1 412  
95 14 Dtool_uZHmwAG8 0 7 52 426 238 14 Dtool_uZHmwAG8 92 /// Create a document with a name. The name of the document is also the filename of the xml. 1 12 documentName 1 412  
96 14 Dtool_uZHmIQ0G 0 6 53 426 0 14 Dtool_uZHmIQ0G 0 2 4 this 3 426  4 copy 1 427  
97 14 Dtool_uZHmYZQT 0 6 54 410 0 14 Dtool_uZHmYZQT 314 /** Load a file using the given FILE*. Returns true if successful. Note that this method
        doesn't stream - the entire object pointed at by the FILE*
        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
        file location. Streaming may be added in the future.
    */ 3 4 this 3 426  6 param0 0 407  8 encoding 1 397  
98 14 Dtool_uZHmp5UJ 0 6 54 410 0 14 Dtool_uZHmp5UJ 314 /** Load a file using the given FILE*. Returns true if successful. Note that this method
        doesn't stream - the entire object pointed at by the FILE*
        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
        file location. Streaming may be added in the future.
    */ 2 4 this 3 426  6 param0 0 407  
99 14 Dtool_uZHmSl79 0 6 54 410 0 14 Dtool_uZHmSl79 155 /** Load a file using the current document value.
        Returns true if successful. Will delete any existing
        document data before loading.
    */ 2 4 this 3 426  8 encoding 1 397  
100 14 Dtool_uZHml9Fw 0 6 54 410 0 14 Dtool_uZHml9Fw 155 /** Load a file using the current document value.
        Returns true if successful. Will delete any existing
        document data before loading.
    */ 1 4 this 3 426  
101 14 Dtool_uZHmRZyg 0 6 54 410 0 14 Dtool_uZHmRZyg 29 ///< STL std::string version. 3 4 this 3 426  8 filename 1 412  8 encoding 1 397  
102 14 Dtool_uZHmnbVO 0 6 54 410 0 14 Dtool_uZHmnbVO 29 ///< STL std::string version. 2 4 this 3 426  8 filename 1 412  
103 14 Dtool_uZHmKryg 0 6 54 410 0 14 Dtool_uZHmKryg 69 /// Load a file using the given filename. Returns true if successful. 3 4 this 3 426  8 filename 1 412  8 encoding 1 397  
104 14 Dtool_uZHmmp0i 0 6 54 410 0 14 Dtool_uZHmmp0i 69 /// Load a file using the given filename. Returns true if successful. 2 4 this 3 426  8 filename 1 412  
105 14 Dtool_uZHmdzVw 0 6 55 410 0 14 Dtool_uZHmdzVw 77 /// Save a file using the current document value. Returns true if successful. 1 4 this 3 427  
106 14 Dtool_uZHmQlra 0 6 55 410 0 14 Dtool_uZHmQlra 66 /// Save a file using the given FILE*. Returns true if successful. 2 4 this 3 427  6 param0 0 407  
107 14 Dtool_uZHmbe6h 0 6 55 410 0 14 Dtool_uZHmbe6h 29 ///< STL std::string version. 2 4 this 3 427  8 filename 1 412  
108 14 Dtool_uZHmvpt6 0 6 55 410 0 14 Dtool_uZHmvpt6 69 /// Save a file using the given filename. Returns true if successful. 2 4 this 3 427  8 filename 1 412  
109 14 Dtool_uZHmwKOL 0 6 56 423 0 14 Dtool_uZHmwKOL 0 1 4 this 3 426  
110 14 Dtool_uZHmH9Do 0 6 56 424 0 14 Dtool_uZHmH9Do 207 /** Get the root element -- the only top level element -- of the document.
        In well formed XML, there should only be one. TinyXml is tolerant of
        multiple elements at the document level.
    */ 1 4 this 3 427  
111 14 Dtool_uZHm6PR8 0 6 57 410 0 14 Dtool_uZHm6PR8 330 /** If an error occurs, Error will be set to true. Also,
        - The ErrorId() will contain the integer identifier of the error (not generally useful)
        - The ErrorDesc() method will return the name of the error. (very useful)
        - The ErrorRow() and ErrorCol() will return the location of the error (if known)
    */ 1 4 this 3 427  
112 14 Dtool_uZHmJP2C 0 6 58 412 0 14 Dtool_uZHmJP2C 72 /// Contains a textual (english) description of the error if one occurs. 1 4 this 3 427  
113 14 Dtool_uZHml916 0 6 59 394 0 14 Dtool_uZHml916 141 /** Generally, you probably want the error string ( ErrorDesc() ). But if you
        prefer the ErrorId, this function will fetch it.
    */ 1 4 this 3 427  
114 14 Dtool_uZHmKp4k 0 6 60 394 0 14 Dtool_uZHmKp4k 360 /** Returns the location (if known) of the error. The first column is column 1, 
        and the first row is row 1. A value of 0 means the row and column wasn't applicable
        (memory errors, for example, have no row/column) or the parser lost the error. (An
        error in the error reporting, in that case.)

        @sa SetTabSize, Row, Column
    */ 1 4 this 3 427  
115 14 Dtool_uZHmQSgz 0 6 61 394 0 14 Dtool_uZHmQSgz 55 ///< The column where the error occured. See ErrorRow() 1 4 this 3 427  
116 14 Dtool_uZHmJLL_ 0 4 62 409 0 14 Dtool_uZHmJLL_ 978 /** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
        to report the correct values for row and column. It does not change the output
        or input in any way.
        
        By calling this method, with a tab size
        greater than 0, the row and column of each node and attribute is stored
        when the file is loaded. Very useful for tracking the DOM back in to
        the source file.

        The tab size is required for calculating the location of nodes. If not
        set, the default of 4 is used. The tabsize is set per document. Setting
        the tabsize to 0 disables row/column tracking.

        Note that row and column tracking is not supported when using operator>>.

        The tab size needs to be enabled before the parse or load. Correct usage:
        @verbatim
        TiXmlDocument doc;
        doc.SetTabSize( 8 );
        doc.Load( "myfile.xml" );
        @endverbatim

        @sa Row, Column
    */ 2 4 this 3 426  8 _tabsize 1 394  
117 14 Dtool_uZHmrJPb 0 6 63 394 0 14 Dtool_uZHmrJPb 0 1 4 this 3 427  
118 14 Dtool_uZHmmZHm 0 4 64 409 0 14 Dtool_uZHmmZHm 152 /** If you have handled the error, it can be reset with this call. The error
        state is automatically cleared if you Parse a new XML block.
    */ 1 4 this 3 426  
119 14 Dtool_uZHmnl_4 0 4 65 409 0 14 Dtool_uZHmnl_4 84 /** Write the document to standard out using formatted printing ("pretty print"). */ 1 4 this 3 427  
120 14 Dtool_uZHmAd8p 0 4 66 409 0 14 Dtool_uZHmAd8p 17 // [internal use] 5 4 this 3 426  3 err 1 394  13 errorLocation 1 412  8 prevData 1 413  8 encoding 1 397  
121 14 Dtool_uZHmZBQ_ 0 7 68 423 238 14 Dtool_uZHmZBQ_ 0 1 6 param0 0 424  
122 14 Dtool_uZHmN9d5 0 7 68 423 238 14 Dtool_uZHmN9d5 28 /// std::string constructor. 1 6 _value 1 412  
123 14 Dtool_uZHmK5y8 0 7 68 423 238 14 Dtool_uZHmK5y8 25 /// Construct an element. 1 8 in_value 1 412  
124 14 Dtool_uZHmVAN4 0 6 69 423 0 14 Dtool_uZHmVAN4 0 2 4 this 3 423  4 base 1 424  
125 14 Dtool_uZHmj7Xq 0 6 70 412 0 14 Dtool_uZHmj7Xq 0 2 4 this 3 424  4 name 1 412  
126 14 Dtool_uZHmuGLD 0 6 70 412 0 14 Dtool_uZHmuGLD 129 /** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
    */ 2 4 this 3 424  4 name 1 412  
127 14 Dtool_uZHmAMbY 0 6 74 394 0 14 Dtool_uZHmAMbY 74 /// QueryStringAttribute examines the attribute - see QueryIntAttribute(). 3 4 this 3 424  4 name 1 412  6 _value 1 415  
128 14 Dtool_uZHmyCcU 0 6 75 394 0 14 Dtool_uZHmyCcU 0 3 4 this 3 424  4 name 1 412  8 outValue 1 415  
129 14 Dtool_uZHmbDew 0 4 76 409 0 14 Dtool_uZHmbDew 25 /// STL std::string form. 3 4 this 3 423  4 name 1 412  6 _value 1 412  
130 14 Dtool_uZHmb8mT 0 4 76 409 0 14 Dtool_uZHmb8mT 26 ///< STL std::string form. 3 4 this 3 423  4 name 1 412  6 _value 1 394  
131 14 Dtool_uZHm_Yn9 0 4 76 409 0 14 Dtool_uZHm_Yn9 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 423  4 name 1 412  6 _value 1 412  
132 14 Dtool_uZHmQG_l 0 4 76 409 0 14 Dtool_uZHmQG_l 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 423  4 name 1 412  5 value 1 394  
133 14 Dtool_uZHmPLXy 0 4 77 409 0 14 Dtool_uZHmPLXy 26 ///< STL std::string form. 3 4 this 3 423  4 name 1 412  5 value 1 439  
134 14 Dtool_uZHmee3E 0 4 77 409 0 14 Dtool_uZHmee3E 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 423  4 name 1 412  5 value 1 439  
135 14 Dtool_uZHmF6br 0 4 78 409 0 14 Dtool_uZHmF6br 26 ///< STL std::string form. 2 4 this 3 423  4 name 1 412  
136 14 Dtool_uZHmVt1I 0 4 78 409 0 14 Dtool_uZHmVt1I 52 /** Deletes an attribute with the given name.
    */ 2 4 this 3 423  4 name 1 412  
137 14 Dtool_uZHmJ1Yx 0 6 79 440 0 14 Dtool_uZHmJ1Yx 48 ///< Access the first attribute in this element. 1 4 this 3 423  
138 14 Dtool_uZHmgPQJ 0 6 79 441 0 14 Dtool_uZHmgPQJ 48 ///< Access the first attribute in this element. 1 4 this 3 424  
139 14 Dtool_uZHm1rOL 0 6 80 440 0 14 Dtool_uZHm1rOL 47 ///< Access the last attribute in this element. 1 4 this 3 423  
140 14 Dtool_uZHmo59l 0 6 80 441 0 14 Dtool_uZHmo59l 47 ///< Access the last attribute in this element. 1 4 this 3 424  
141 14 Dtool_uZHmOxP9 0 6 81 412 0 14 Dtool_uZHmOxP9 1291 /** Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.
    
        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement->GetText();
        @endverbatim

        'str' will be a pointer to "This is text". 
        
        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo> 
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo> 
        @endverbatim
        GetText() will return "This is ".

        WARNING: GetText() accesses a child node - don't become confused with the 
                 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
                 safe type casts on the referenced node.
    */ 1 4 this 3 424  
142 14 Dtool_uZHmI6g6 0 6 97 410 0 14 Dtool_uZHmI6g6 7 /*doc*/ 2 4 this 3 438  6 param0 0 427  
143 14 Dtool_uZHmHXA5 0 6 97 410 0 14 Dtool_uZHmHXA5 18 /*firstAttribute*/ 3 4 this 3 438  6 param0 0 424  6 param1 0 441  
144 14 Dtool_uZHmR02t 0 6 98 410 0 14 Dtool_uZHmR02t 7 /*doc*/ 2 4 this 3 438  6 param0 0 427  
145 14 Dtool_uZHmiM8H 0 6 98 410 0 14 Dtool_uZHmiM8H 11 /*element*/ 2 4 this 3 438  6 param0 0 424  
146 14 Dtool_uZHmlHHV 0 6 99 410 0 14 Dtool_uZHmlHHV 11 /*comment*/ 2 4 this 3 438  6 param0 0 430  
147 14 Dtool_uZHm30Wf 0 6 99 410 0 14 Dtool_uZHm30Wf 15 /*declaration*/ 2 4 this 3 438  6 param0 0 418  
148 14 Dtool_uZHmKHOX 0 6 99 410 0 14 Dtool_uZHmKHOX 8 /*text*/ 2 4 this 3 438  6 param0 0 436  
149 14 Dtool_uZHmQo3n 0 6 99 410 0 14 Dtool_uZHmQo3n 11 /*unknown*/ 2 4 this 3 438  6 param0 0 433  
150 14 Dtool_uZHmH66i 0 7 104 440 345 14 Dtool_uZHmH66i 33 /// Construct an empty attribute. 0 
151 14 Dtool_uZHmUpwU 0 7 104 440 345 14 Dtool_uZHmUpwU 28 /// std::string constructor. 2 5 _name 1 412  6 _value 1 412  
152 14 Dtool_uZHmIumt 0 7 104 440 345 14 Dtool_uZHmIumt 49 /// Construct an attribute with a name and value. 2 5 _name 1 412  6 _value 1 412  
153 14 Dtool_uZHm8eA9 0 6 105 412 0 14 Dtool_uZHm8eA9 39 ///< Return the name of this attribute. 1 4 this 3 441  
154 14 Dtool_uZHmy__V 0 6 106 412 0 14 Dtool_uZHmy__V 40 ///< Return the value of this attribute. 1 4 this 3 441  
155 14 Dtool_uZHmt9iI 0 6 107 412 0 14 Dtool_uZHmt9iI 40 ///< Return the value of this attribute. 1 4 this 3 441  
156 14 Dtool_uZHmKq9E 0 6 108 394 0 14 Dtool_uZHmKq9E 65 ///< Return the value of this attribute, converted to an integer. 1 4 this 3 441  
157 14 Dtool_uZHmvQig 0 6 109 439 0 14 Dtool_uZHmvQig 63 ///< Return the value of this attribute, converted to a double. 1 4 this 3 441  
158 14 Dtool_uZHmgsLj 0 6 110 412 0 14 Dtool_uZHmgsLj 40 // Get the tinyxml string representation 1 4 this 3 441  
159 14 Dtool_uZHmCzNr 0 4 113 409 0 14 Dtool_uZHmCzNr 25 /// STL std::string form. 2 4 this 3 440  5 _name 1 412  
160 14 Dtool_uZHmDVs_ 0 4 113 409 0 14 Dtool_uZHmDVs_ 36 ///< Set the name of this attribute. 2 4 this 3 440  5 _name 1 412  
161 14 Dtool_uZHmHNwC 0 4 114 409 0 14 Dtool_uZHmHNwC 25 /// STL std::string form. 2 4 this 3 440  6 _value 1 412  
162 14 Dtool_uZHmmjfR 0 4 114 409 0 14 Dtool_uZHmmjfR 19 ///< Set the value. 2 4 this 3 440  6 _value 1 412  
163 14 Dtool_uZHmdzvz 0 4 115 409 0 14 Dtool_uZHmdzvz 35 ///< Set the value from an integer. 2 4 this 3 440  6 _value 1 394  
164 14 Dtool_uZHm_JrU 0 4 116 409 0 14 Dtool_uZHm_JrU 33 ///< Set the value from a double. 2 4 this 3 440  6 _value 1 439  
165 14 Dtool_uZHmxsmy 0 6 117 440 0 14 Dtool_uZHmxsmy 0 1 4 this 3 440  
166 14 Dtool_uZHmWgCb 0 6 117 441 0 14 Dtool_uZHmWgCb 67 /// Get the next sibling attribute in the DOM. Returns null at end. 1 4 this 3 441  
167 14 Dtool_uZHmp5iU 0 6 118 440 0 14 Dtool_uZHmp5iU 0 1 4 this 3 440  
168 14 Dtool_uZHm8eDT 0 6 118 441 0 14 Dtool_uZHm8eDT 77 /// Get the previous sibling attribute in the DOM. Returns null at beginning. 1 4 this 3 441  
169 14 Dtool_uZHmSkU5 0 6 119 410 0 14 Dtool_uZHmSkU5 0 2 4 this 3 441  3 rhs 1 441  
170 14 Dtool_uZHmeYqO 0 6 120 410 0 14 Dtool_uZHmeYqO 0 2 4 this 3 441  3 rhs 1 441  
171 14 Dtool_uZHmeh5P 0 6 121 410 0 14 Dtool_uZHmeh5P 0 2 4 this 3 441  3 rhs 1 441  
172 14 Dtool_uZHmKlAG 0 4 122 409 0 14 Dtool_uZHmKlAG 9 /*depth*/ 4 4 this 3 441  5 cfile 1 407  5 depth 1 394  3 str 1 415  
173 14 Dtool_uZHmn16J 0 4 123 409 0 14 Dtool_uZHmn16J 81 // [internal use]
// Set the document pointer so the attribute can report errors. 2 4 this 3 440  3 doc 1 426  
174 14 Dtool_uZHmshIH 0 7 126 443 347 14 Dtool_uZHmshIH 0 0 
175 14 Dtool_uZHmT3Tb 0 4 128 409 0 14 Dtool_uZHmT3Tb 0 2 4 this 3 443  9 attribute 1 440  
176 14 Dtool_uZHmQUKM 0 4 129 409 0 14 Dtool_uZHmQUKM 0 2 4 this 3 443  9 attribute 1 440  
177 14 Dtool_uZHmXUpb 0 6 130 440 0 14 Dtool_uZHmXUpb 0 1 4 this 3 443  
178 14 Dtool_uZHmAKLa 0 6 130 441 0 14 Dtool_uZHmAKLa 0 1 4 this 3 444  
179 14 Dtool_uZHm3Bba 0 6 131 440 0 14 Dtool_uZHm3Bba 0 1 4 this 3 443  
180 14 Dtool_uZHmXmXG 0 6 131 441 0 14 Dtool_uZHmXmXG 0 1 4 this 3 444  
181 14 Dtool_uZHmxZfC 0 6 132 440 0 14 Dtool_uZHmxZfC 0 2 4 this 3 444  5 _name 1 412  
182 14 Dtool_uZHmlmTb 0 6 132 440 0 14 Dtool_uZHmlmTb 0 2 4 this 3 444  5 _name 1 412  
183 14 Dtool_uZHmvaUt 0 6 133 440 0 14 Dtool_uZHmvaUt 0 2 4 this 3 443  5 _name 1 412  
184 14 Dtool_uZHmL_7z 0 6 133 440 0 14 Dtool_uZHmL_7z 0 2 4 this 3 443  5 _name 1 412  
185 14 Dtool_uZHmw3oy 0 7 135 429 238 14 Dtool_uZHmw3oy 32 /// Constructs an empty comment. 0 
186 14 Dtool_uZHmcqZv 0 7 135 429 238 14 Dtool_uZHmcqZv 0 1 6 param0 0 430  
187 14 Dtool_uZHm8NzH 0 7 135 429 238 14 Dtool_uZHm8NzH 34 /// Construct a comment from text. 1 6 _value 1 412  
188 14 Dtool_uZHmM080 0 6 136 429 0 14 Dtool_uZHmM080 0 2 4 this 3 429  4 base 1 430  
189 14 Dtool_uZHmeOj2 0 7 138 435 238 14 Dtool_uZHmeOj2 0 1 4 copy 1 436  
190 14 Dtool_uZHmKgtp 0 7 138 435 238 14 Dtool_uZHmKgtp 16 /// Constructor. 1 9 initValue 1 412  
191 14 Dtool_uZHm_HyU 0 7 138 435 238 14 Dtool_uZHm_HyU 193 /** Constructor for text element. By default, it is treated as 
        normal, encoded text. If you want it be output as a CDATA text
        element, set the parameter _cdata to 'true'
    */ 1 9 initValue 1 412  
192 14 Dtool_uZHmhJMH 0 6 139 435 0 14 Dtool_uZHmhJMH 0 2 4 this 3 435  4 base 1 436  
193 14 Dtool_uZHm_NZE 0 6 140 410 0 14 Dtool_uZHm_NZE 63 /// Queries whether this represents text using a CDATA section. 1 4 this 3 436  
194 14 Dtool_uZHm8loy 0 4 141 409 0 14 Dtool_uZHm8loy 51 /// Turns on or off a CDATA representation of text. 2 4 this 3 435  6 _cdata 1 410  
195 14 Dtool_uZHmWAFV 0 7 143 432 238 14 Dtool_uZHmWAFV 0 0 
196 14 Dtool_uZHmBaNI 0 7 143 432 238 14 Dtool_uZHmBaNI 0 1 4 copy 1 433  
197 14 Dtool_uZHm8emP 0 6 144 432 0 14 Dtool_uZHm8emP 0 2 4 this 3 432  4 copy 1 433  
198 14 Dtool_uZHmyTNp 0 7 146 448 376 14 Dtool_uZHmyTNp 20 /// Copy constructor 1 3 ref 1 446  
199 14 Dtool_uZHmup_j 0 7 146 448 376 14 Dtool_uZHmup_j 89 /// Create a handle from any node (at any depth of the tree.) This can be a null pointer. 1 5 _node 1 422  
200 14 Dtool_uZHm4HhA 0 6 147 448 0 14 Dtool_uZHm4HhA 0 2 4 this 3 448  3 ref 1 446  
201 14 Dtool_uZHm7eRe 0 7 148 448 376 14 Dtool_uZHm7eRe 44 /// Return a handle to the first child node. 1 4 this 3 446  
202 14 Dtool_uZHm9w1P 0 7 148 448 376 14 Dtool_uZHm9w1P 0 2 4 this 3 446  6 _value 1 412  
203 14 Dtool_uZHmploo 0 7 148 448 376 14 Dtool_uZHmploo 64 /// Return a handle to the first child node with the given name. 2 4 this 3 446  5 value 1 412  
204 14 Dtool_uZHmCHfA 0 7 149 448 376 14 Dtool_uZHmCHfA 47 /// Return a handle to the first child element. 1 4 this 3 446  
205 14 Dtool_uZHm3znc 0 7 149 448 376 14 Dtool_uZHm3znc 0 2 4 this 3 446  6 _value 1 412  
206 14 Dtool_uZHmB_9B 0 7 149 448 376 14 Dtool_uZHmB_9B 67 /// Return a handle to the first child element with the given name. 2 4 this 3 446  5 value 1 412  
207 14 Dtool_uZHmFRvl 0 7 150 448 376 14 Dtool_uZHmFRvl 0 3 4 this 3 446  6 _value 1 412  5 index 1 394  
208 14 Dtool_uZHmlodA 0 7 150 448 376 14 Dtool_uZHmlodA 118 /** Return a handle to the "index" child with the given name. 
        The first child is 0, the second 1, etc.
    */ 3 4 this 3 446  5 value 1 412  5 index 1 394  
209 14 Dtool_uZHma_Mf 0 7 150 448 376 14 Dtool_uZHma_Mf 98 /** Return a handle to the "index" child. 
        The first child is 0, the second 1, etc.
    */ 2 4 this 3 446  5 index 1 394  
210 14 Dtool_uZHmnyJX 0 7 151 448 376 14 Dtool_uZHmnyJX 0 3 4 this 3 446  6 _value 1 412  5 index 1 394  
211 14 Dtool_uZHmeV2M 0 7 151 448 376 14 Dtool_uZHmeV2M 213 /** Return a handle to the "index" child element with the given name. 
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */ 3 4 this 3 446  5 value 1 412  5 index 1 394  
212 14 Dtool_uZHm8B4Z 0 7 151 448 376 14 Dtool_uZHm8B4Z 193 /** Return a handle to the "index" child element. 
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */ 2 4 this 3 446  5 index 1 394  
213 14 Dtool_uZHmEj7k 0 6 152 422 0 14 Dtool_uZHmEj7k 66 /** Return the handle as a TiXmlNode. This may return null.
    */ 1 4 this 3 446  
214 14 Dtool_uZHmqg9o 0 6 153 423 0 14 Dtool_uZHmqg9o 69 /** Return the handle as a TiXmlElement. This may return null.
    */ 1 4 this 3 446  
215 14 Dtool_uZHmwqZS 0 6 154 435 0 14 Dtool_uZHmwqZS 66 /** Return the handle as a TiXmlText. This may return null.
    */ 1 4 this 3 446  
216 14 Dtool_uZHmz2vt 0 6 155 432 0 14 Dtool_uZHmz2vt 69 /** Return the handle as a TiXmlUnknown. This may return null.
    */ 1 4 this 3 446  
217 14 Dtool_uZHmyl27 0 6 156 422 0 14 Dtool_uZHmyl27 99 /** @deprecated use ToNode. 
        Return the handle as a TiXmlNode. This may return null.
    */ 1 4 this 3 446  
218 14 Dtool_uZHmgHTv 0 6 157 423 0 14 Dtool_uZHmgHTv 105 /** @deprecated use ToElement. 
        Return the handle as a TiXmlElement. This may return null.
    */ 1 4 this 3 446  
219 14 Dtool_uZHm8vF9 0 6 158 435 0 14 Dtool_uZHm8vF9 99 /** @deprecated use ToText()
        Return the handle as a TiXmlText. This may return null.
    */ 1 4 this 3 446  
220 14 Dtool_uZHmaaPm 0 6 159 432 0 14 Dtool_uZHmaaPm 105 /** @deprecated use ToUnknown()
        Return the handle as a TiXmlUnknown. This may return null.
    */ 1 4 this 3 446  
221 14 Dtool_uZHmaS0B 0 7 162 449 386 14 Dtool_uZHmaS0B 0 0 
222 14 Dtool_uZHmSptS 0 4 163 409 0 14 Dtool_uZHmSptS 148 /** Set the indent characters for printing. By default 4 spaces
        but tab (\t) is also useful, or null/empty string for no indentation.
    */ 2 4 this 3 449  7 _indent 1 412  
223 14 Dtool_uZHmd4nR 0 6 164 412 0 14 Dtool_uZHmd4nR 31 /// Query the indention string. 1 4 this 3 449  
224 14 Dtool_uZHmxjzB 0 4 165 409 0 14 Dtool_uZHmxjzB 195 /** Set the line breaking string. By default set to newline (\n). 
        Some operating systems prefer other characters, or can be
        set to the null/empty string for no indenation.
    */ 2 4 this 3 449  10 _lineBreak 1 412  
225 14 Dtool_uZHmNmra 0 6 166 412 0 14 Dtool_uZHmNmra 43 /// Query the current line breaking string. 1 4 this 3 449  
226 14 Dtool_uZHmQpQV 0 4 167 409 0 14 Dtool_uZHmQpQV 163 /** Switch over to "stream printing" which is the most dense formatting without 
        linebreaks. Common when the XML is needed for network transmission.
    */ 1 4 this 3 449  
227 14 Dtool_uZHmQnJD 0 6 168 412 0 14 Dtool_uZHmQnJD 22 /// Return the result. 1 4 this 3 449  
228 14 Dtool_uZHmMFC1 0 6 169 450 0 14 Dtool_uZHmMFC1 43 /// Return the length of the result string. 1 4 this 3 449  
229 14 Dtool_uZHmkP78 0 6 170 412 0 14 Dtool_uZHmkP78 22 /// Return the result. 1 4 this 3 449  
230 14 Dtool_uZHm5xCc 0 6 82 426 0 14 Dtool_uZHm5xCc 293 ////////////////////////////////////////////////////////////////////
//     Function: read_xml_stream
//  Description: Reads an XML document from the indicated stream.
//               Returns the document, or NULL on error.
//////////////////////////////////////////////////////////////////// 1 2 in 1 451  
231 14 Dtool_uZHmoEHe 0 4 83 409 0 14 Dtool_uZHmoEHe 0 2 3 out 1 453  3 doc 1 426  
232 14 Dtool_uZHmsOCd 0 4 84 409 0 14 Dtool_uZHmsOCd 0 1 5 xnode 1 422  
233 14 Dtool_uZHmlNiD 0 4 85 409 0 14 Dtool_uZHmlNiD 0 2 8 filename 1 455  5 xnode 1 422  
234 14 Dtool_uZHm3838 0 6 87 394 0 14 Dtool_uZHm3838 0 0 
235 14 Dtool_uZHmps1I 0 6 89 394 0 14 Dtool_uZHmps1I 0 0 
236 14 Dtool_uZHmAfJA 0 6 91 394 0 14 Dtool_uZHmAfJA 0 0 
237 14 Dtool_uZHmNfVn 0 6 101 397 0 14 Dtool_uZHmNfVn 0 0 
71
387 9 TiXmlBase 0 26625 9 TiXmlBase 9 TiXmlBase 0 0 0 0 238 0 9 239 240 241 242 243 244 245 246 247 0 0 0 0 1 388 786
/** TiXmlBase is a base class for every class in TinyXml.
    It does little except to establish that TinyXml classes
    can be printed and provide some utility functions.

    In XML, the document and elements can contain
    other elements and other types of nodes.

    @verbatim
    A Document can contain: Element (container or leaf)
                            Comment (leaf)
                            Unknown (leaf)
                            Declaration( leaf )

    An Element can contain: Element (container or leaf)
                            Text    (leaf)
                            Attributes (not on tree)
                            Comment (leaf)
                            Unknown (leaf)

    A Decleration contains: Attributes (not on tree)
    @endverbatim
*/

388 0 0 532480 0 0 0 0 0 0 0 0 0 0 0 0 17 14 TIXML_NO_ERROR 14 TIXML_NO_ERROR 0
0 11 TIXML_ERROR 11 TIXML_ERROR 0
1 24 TIXML_ERROR_OPENING_FILE 24 TIXML_ERROR_OPENING_FILE 0
2 27 TIXML_ERROR_PARSING_ELEMENT 27 TIXML_ERROR_PARSING_ELEMENT 0
3 39 TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME 39 TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME 0
4 33 TIXML_ERROR_READING_ELEMENT_VALUE 33 TIXML_ERROR_READING_ELEMENT_VALUE 0
5 30 TIXML_ERROR_READING_ATTRIBUTES 30 TIXML_ERROR_READING_ATTRIBUTES 0
6 25 TIXML_ERROR_PARSING_EMPTY 25 TIXML_ERROR_PARSING_EMPTY 0
7 27 TIXML_ERROR_READING_END_TAG 27 TIXML_ERROR_READING_END_TAG 0
8 27 TIXML_ERROR_PARSING_UNKNOWN 27 TIXML_ERROR_PARSING_UNKNOWN 0
9 27 TIXML_ERROR_PARSING_COMMENT 27 TIXML_ERROR_PARSING_COMMENT 0
10 31 TIXML_ERROR_PARSING_DECLARATION 31 TIXML_ERROR_PARSING_DECLARATION 0
11 26 TIXML_ERROR_DOCUMENT_EMPTY 26 TIXML_ERROR_DOCUMENT_EMPTY 0
12 25 TIXML_ERROR_EMBEDDED_NULL 25 TIXML_ERROR_EMBEDDED_NULL 0
13 25 TIXML_ERROR_PARSING_CDATA 25 TIXML_ERROR_PARSING_CDATA 0
14 29 TIXML_ERROR_DOCUMENT_TOP_ONLY 29 TIXML_ERROR_DOCUMENT_TOP_ONLY 0
15 24 TIXML_ERROR_STRING_COUNT 24 TIXML_ERROR_STRING_COUNT 0
16 0 0

389 16 TiXmlDeclaration 0 75777 16 TiXmlDeclaration 16 TiXmlDeclaration 0 0 0 1 277 238 0 5 278 279 280 281 282 0 0 1 0 390 0 0 0 0 510
/** In correct XML the declaration is the first entry in the file.
    @verbatim
        <?xml version="1.0" standalone="yes"?>
    @endverbatim

    TinyXml will happily read or write files without a declaration,
    however. There are 3 possible attributes to the declaration:
    version, encoding, and standalone.

    Note: In this version of the code, the attributes are
    handled as special cases, not generic attributes, simply
    because there can only be at most 3 and they are always the same.
*/

390 9 TiXmlNode 0 75777 9 TiXmlNode 9 TiXmlNode 0 0 0 0 238 0 29 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 0 0 1 0 387 0 0 0 1 391 289
/** The parent class for everything in the Document Object Model.
    (Except for attributes).
    Nodes have siblings, a parent, and children. A node can be
    in a document, or stand on its own. The type of a TiXmlNode
    can be queried, and it can be cast to its more defined type.
*/

391 8 NodeType 0 794624 19 TiXmlNode::NodeType 19 TiXmlNode::NodeType 390 0 0 0 0 0 0 0 0 0 7 16 TINYXML_DOCUMENT 27 TiXmlNode::TINYXML_DOCUMENT 0
0 15 TINYXML_ELEMENT 26 TiXmlNode::TINYXML_ELEMENT 0
1 15 TINYXML_COMMENT 26 TiXmlNode::TINYXML_COMMENT 0
2 15 TINYXML_UNKNOWN 26 TiXmlNode::TINYXML_UNKNOWN 0
3 12 TINYXML_TEXT 23 TiXmlNode::TINYXML_TEXT 0
4 19 TINYXML_DECLARATION 30 TiXmlNode::TINYXML_DECLARATION 0
5 17 TINYXML_TYPECOUNT 28 TiXmlNode::TINYXML_TYPECOUNT 0
6 0 121
/** The types of XML nodes supported by TinyXml. (All the
            unsupported types are picked up by UNKNOWN.)
    */

392 13 TiXmlDocument 0 75777 13 TiXmlDocument 13 TiXmlDocument 0 0 0 1 283 238 0 14 284 285 286 287 288 289 290 291 292 293 294 295 296 297 0 0 1 0 390 0 0 0 0 192
/** Always the top level node. A document binds together all the
    XML pieces. It can be saved, loaded, and printed to the screen.
    The 'value' of a document node is the xml file name.
*/

393 12 TiXmlElement 0 75777 12 TiXmlElement 12 TiXmlElement 0 0 0 1 298 238 0 13 299 300 301 302 303 304 305 306 307 308 309 310 311 0 0 1 0 390 0 0 0 0 201
/** The element is a container class. It has a value, the element name,
    and can contain other elements, text, comments, and unknowns.
    Elements also contain an arbitrary number of attributes.
*/

394 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

395 11 TiXmlCursor 0 140289 11 TiXmlCursor 11 TiXmlCursor 0 0 0 0 319 0 0 0 0 0 0 0 78
/*  Internal structure for tracking location of items 
    in the XML file.
*/

396 12 TiXmlVisitor 0 26625 12 TiXmlVisitor 12 TiXmlVisitor 0 0 0 0 320 0 3 321 322 323 0 0 0 0 0 898
/**
    Implements the interface to the "Visitor pattern" (see the Accept() method.)
    If you call the Accept() method, it requires being passed a TiXmlVisitor
    class to handle callbacks. For nodes that contain other nodes (Document, Element)
    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
    are simply called with Visit().

    If you return 'true' from a Visit method, recursive parsing will continue. If you return
    false, <b>no children of this node or its sibilings</b> will be Visited.

    All flavors of Visit methods have a default implementation that returns 'true' (continue 
    visiting). You need to only override methods that are interesting to you.

    Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.

    You should never change the document from a callback.

    @sa TiXmlNode::Accept()
*/

397 13 TiXmlEncoding 0 532481 13 TiXmlEncoding 13 TiXmlEncoding 0 0 0 0 0 0 0 0 0 0 3 22 TIXML_ENCODING_UNKNOWN 22 TIXML_ENCODING_UNKNOWN 0
0 19 TIXML_ENCODING_UTF8 19 TIXML_ENCODING_UTF8 0
1 21 TIXML_ENCODING_LEGACY 21 TIXML_ENCODING_LEGACY 0
2 0 32
// Used by the parsing routines.

398 14 TiXmlAttribute 0 141313 14 TiXmlAttribute 14 TiXmlAttribute 0 0 0 1 325 345 0 19 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 0 0 1 0 387 0 0 0 0 303
/** An attribute is a name-value pair. Elements have an arbitrary
    number of attributes, each with a unique name.

    @note The attributes are not TiXmlNodes, since they are not
          part of the tinyXML document object model. There are other
          suggested ways to look at this problem.
*/

399 17 TiXmlAttributeSet 0 26625 17 TiXmlAttributeSet 17 TiXmlAttributeSet 0 0 0 1 346 347 0 6 348 349 350 351 352 353 0 0 0 0 0 564
/*  A class used to manage a group of attributes.
    It is only used internally, both by the ELEMENT and the DECLARATION.
    
    The set can be changed transparent to the Element and Declaration
    classes that use it, but NOT transparent to the Attribute
    which has to implement a next() and previous() method. Which makes
    it a bit problematic and prevents the use of STL.

    This version is implemented with circular lists because:
        - I like circular lists
        - it demonstrates some independence from the (typical) doubly linked list.
*/

400 12 TiXmlComment 0 75777 12 TiXmlComment 12 TiXmlComment 0 0 0 1 354 238 0 1 355 0 0 1 0 390 0 0 0 0 22
/** An XML comment.
*/

401 9 TiXmlText 0 75777 9 TiXmlText 9 TiXmlText 0 0 0 1 356 238 0 3 357 358 359 0 0 1 0 390 0 0 0 0 285
/** XML text. A text node can have 2 ways to output the next. "normal" output 
    and CDATA. It will default to the mode it was parsed from the XML file and
    you generally want to leave it alone, but you can change the output mode with 
    SetCDATA() and query it with CDATA().
*/

402 12 TiXmlUnknown 0 75777 12 TiXmlUnknown 12 TiXmlUnknown 0 0 0 1 360 238 0 1 361 0 0 1 0 390 0 0 0 0 246
/** Any tag that tinyXml doesn't recognize is saved as an
    unknown. It is a tag of text, but should not be modified.
    It will be written back to the XML, unchanged, when the file
    is saved.

    DTD tags get thrown into TiXmlUnknowns.
*/

403 11 TiXmlHandle 0 141313 11 TiXmlHandle 11 TiXmlHandle 0 0 0 1 362 376 0 13 363 364 365 366 367 368 369 370 371 372 373 374 375 0 0 0 0 0 2524
/**
    A TiXmlHandle is a class that wraps a node pointer with null checks; this is
    an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
    DOM structure. It is a separate utility class.

    Take an example:
    @verbatim
    <Document>
        <Element attributeA = "valueA">
            <Child attributeB = "value1" />
            <Child attributeB = "value2" />
        </Element>
    <Document>
    @endverbatim

    Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
    easy to write a *lot* of code that looks like:

    @verbatim
    TiXmlElement* root = document.FirstChildElement( "Document" );
    if ( root )
    {
        TiXmlElement* element = root->FirstChildElement( "Element" );
        if ( element )
        {
            TiXmlElement* child = element->FirstChildElement( "Child" );
            if ( child )
            {
                TiXmlElement* child2 = child->NextSiblingElement( "Child" );
                if ( child2 )
                {
                    // Finally do something useful.
    @endverbatim

    And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
    of such code. A TiXmlHandle checks for null pointers so it is perfectly safe 
    and correct to use:

    @verbatim
    TiXmlHandle docHandle( &document );
    TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
    if ( child2 )
    {
        // do something useful
    @endverbatim

    Which is MUCH more concise and useful.

    It is also safe to copy handles - internally they are nothing more than node pointers.
    @verbatim
    TiXmlHandle handleCopy = handle;
    @endverbatim

    What they should not be used for is iteration:

    @verbatim
    int i=0; 
    while ( true )
    {
        TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
        if ( !child )
            break;
        // do something
        ++i;
    }
    @endverbatim

    It seems reasonable, but it is in fact two embedded while loops. The Child method is 
    a linear walk to find the element, so this code would iterate much more than it needs 
    to. Instead, prefer:

    @verbatim
    TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();

    for( child; child; child=child->NextSiblingElement() )
    {
        // do something
    }
    @endverbatim
*/

404 12 TiXmlPrinter 0 141313 12 TiXmlPrinter 12 TiXmlPrinter 0 0 0 1 377 386 0 8 378 379 380 381 382 383 384 385 0 0 1 0 396 0 0 0 0 685
/** Print to memory functionality. The TiXmlPrinter is useful when you need to:

    -# Print to memory (especially in non-STL mode)
    -# Control formatting (line endings, etc.)

    When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
    Before calling Accept() you can call methods to control the printing
    of the XML document. After TiXmlNode::Accept() is called, the printed document can
    be accessed via the CStr(), Str(), and Size() methods.

    TiXmlPrinter uses the Visitor API.
    @verbatim
    TiXmlPrinter printer;
    printer.SetIndent( "\t" );

    doc.Accept( &printer );
    fprintf( stdout, "%s", printer.CStr() );
    @endverbatim
*/

405 17 TiXmlBase const * 0 8576 17 TiXmlBase const * 17 TiXmlBase const * 0 0 406 0 0 0 0 0 0 0 0 0 0

406 15 TiXmlBase const 0 8832 15 TiXmlBase const 15 TiXmlBase const 0 0 387 0 0 0 0 0 0 0 0 0 0

407 6 FILE * 0 8576 6 FILE * 6 FILE * 0 0 408 0 0 0 0 0 0 0 0 0 0

408 4 FILE 0 1024 4 FILE 4 FILE 0 0 0 0 0 0 0 0 0 0 0 0 0

409 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

410 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

411 11 TiXmlBase * 0 8576 11 TiXmlBase * 11 TiXmlBase * 0 0 387 0 0 0 0 0 0 0 0 0 0

412 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

413 18 TiXmlParsingData * 0 8576 18 TiXmlParsingData * 18 TiXmlParsingData * 0 0 414 0 0 0 0 0 0 0 0 0 0

414 16 TiXmlParsingData 0 2048 16 TiXmlParsingData 16 TiXmlParsingData 0 0 0 0 0 0 0 0 0 0 0 0 0

415 22 basic_string< char > * 0 8576 22 basic_string< char > * 22 basic_string< char > * 0 0 416 0 0 0 0 0 0 0 0 0 0

416 6 string 0 2048 20 basic_string< char > 20 basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

417 18 TiXmlDeclaration * 0 8576 18 TiXmlDeclaration * 18 TiXmlDeclaration * 0 0 389 0 0 0 0 0 0 0 0 0 0

418 24 TiXmlDeclaration const * 0 8576 24 TiXmlDeclaration const * 24 TiXmlDeclaration const * 0 0 419 0 0 0 0 0 0 0 0 0 0

419 22 TiXmlDeclaration const 0 8832 22 TiXmlDeclaration const 22 TiXmlDeclaration const 0 0 389 0 0 0 0 0 0 0 0 0 0

420 17 TiXmlNode const * 0 8576 17 TiXmlNode const * 17 TiXmlNode const * 0 0 421 0 0 0 0 0 0 0 0 0 0

421 15 TiXmlNode const 0 8832 15 TiXmlNode const 15 TiXmlNode const 0 0 390 0 0 0 0 0 0 0 0 0 0

422 11 TiXmlNode * 0 8576 11 TiXmlNode * 11 TiXmlNode * 0 0 390 0 0 0 0 0 0 0 0 0 0

423 14 TiXmlElement * 0 8576 14 TiXmlElement * 14 TiXmlElement * 0 0 393 0 0 0 0 0 0 0 0 0 0

424 20 TiXmlElement const * 0 8576 20 TiXmlElement const * 20 TiXmlElement const * 0 0 425 0 0 0 0 0 0 0 0 0 0

425 18 TiXmlElement const 0 8832 18 TiXmlElement const 18 TiXmlElement const 0 0 393 0 0 0 0 0 0 0 0 0 0

426 15 TiXmlDocument * 0 8576 15 TiXmlDocument * 15 TiXmlDocument * 0 0 392 0 0 0 0 0 0 0 0 0 0

427 21 TiXmlDocument const * 0 8576 21 TiXmlDocument const * 21 TiXmlDocument const * 0 0 428 0 0 0 0 0 0 0 0 0 0

428 19 TiXmlDocument const 0 8832 19 TiXmlDocument const 19 TiXmlDocument const 0 0 392 0 0 0 0 0 0 0 0 0 0

429 14 TiXmlComment * 0 8576 14 TiXmlComment * 14 TiXmlComment * 0 0 400 0 0 0 0 0 0 0 0 0 0

430 20 TiXmlComment const * 0 8576 20 TiXmlComment const * 20 TiXmlComment const * 0 0 431 0 0 0 0 0 0 0 0 0 0

431 18 TiXmlComment const 0 8832 18 TiXmlComment const 18 TiXmlComment const 0 0 400 0 0 0 0 0 0 0 0 0 0

432 14 TiXmlUnknown * 0 8576 14 TiXmlUnknown * 14 TiXmlUnknown * 0 0 402 0 0 0 0 0 0 0 0 0 0

433 20 TiXmlUnknown const * 0 8576 20 TiXmlUnknown const * 20 TiXmlUnknown const * 0 0 434 0 0 0 0 0 0 0 0 0 0

434 18 TiXmlUnknown const 0 8832 18 TiXmlUnknown const 18 TiXmlUnknown const 0 0 402 0 0 0 0 0 0 0 0 0 0

435 11 TiXmlText * 0 8576 11 TiXmlText * 11 TiXmlText * 0 0 401 0 0 0 0 0 0 0 0 0 0

436 17 TiXmlText const * 0 8576 17 TiXmlText const * 17 TiXmlText const * 0 0 437 0 0 0 0 0 0 0 0 0 0

437 15 TiXmlText const 0 8832 15 TiXmlText const 15 TiXmlText const 0 0 401 0 0 0 0 0 0 0 0 0 0

438 14 TiXmlVisitor * 0 8576 14 TiXmlVisitor * 14 TiXmlVisitor * 0 0 396 0 0 0 0 0 0 0 0 0 0

439 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

440 16 TiXmlAttribute * 0 8576 16 TiXmlAttribute * 16 TiXmlAttribute * 0 0 398 0 0 0 0 0 0 0 0 0 0

441 22 TiXmlAttribute const * 0 8576 22 TiXmlAttribute const * 22 TiXmlAttribute const * 0 0 442 0 0 0 0 0 0 0 0 0 0

442 20 TiXmlAttribute const 0 8832 20 TiXmlAttribute const 20 TiXmlAttribute const 0 0 398 0 0 0 0 0 0 0 0 0 0

443 19 TiXmlAttributeSet * 0 8576 19 TiXmlAttributeSet * 19 TiXmlAttributeSet * 0 0 399 0 0 0 0 0 0 0 0 0 0

444 25 TiXmlAttributeSet const * 0 8576 25 TiXmlAttributeSet const * 25 TiXmlAttributeSet const * 0 0 445 0 0 0 0 0 0 0 0 0 0

445 23 TiXmlAttributeSet const 0 8832 23 TiXmlAttributeSet const 23 TiXmlAttributeSet const 0 0 399 0 0 0 0 0 0 0 0 0 0

446 19 TiXmlHandle const * 0 8576 19 TiXmlHandle const * 19 TiXmlHandle const * 0 0 447 0 0 0 0 0 0 0 0 0 0

447 17 TiXmlHandle const 0 8832 17 TiXmlHandle const 17 TiXmlHandle const 0 0 403 0 0 0 0 0 0 0 0 0 0

448 13 TiXmlHandle * 0 8576 13 TiXmlHandle * 13 TiXmlHandle * 0 0 403 0 0 0 0 0 0 0 0 0 0

449 14 TiXmlPrinter * 0 8576 14 TiXmlPrinter * 14 TiXmlPrinter * 0 0 404 0 0 0 0 0 0 0 0 0 0

450 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

451 9 istream * 0 8576 9 istream * 9 istream * 0 0 452 0 0 0 0 0 0 0 0 0 0

452 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

453 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 454 0 0 0 0 0 0 0 0 0 0

454 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

455 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 456 0 0 0 0 0 0 0 0 0 0

456 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 457 0 0 0 0 0 0 0 0 0 0

457 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 869
////////////////////////////////////////////////////////////////////
//       Class : Filename
// Description : The name of a file, such as a texture file or an Egg
//               file.  Stores the full pathname, and includes
//               functions for extracting out the directory prefix
//               part and the file extension and stuff.
//
//               A Filename is also aware of the mapping between the
//               Unix-like filename convention we use internally, and
//               the local OS's specific filename convention, and it
//               knows how to perform basic OS-specific I/O, like
//               testing for file existence and searching a
//               searchpath, as well as the best way to open an
//               fstream for reading or writing.
////////////////////////////////////////////////////////////////////

5
458 16 TINYXML_INCLUDED 0 0 0 0 0 0 
459 10 TIXML_SAFE 0 0 0 0 0 0 
460 14 TIXML_SNPRINTF 0 0 0 0 0 11 _snprintf_s 
461 12 TIXML_SSCANF 0 0 0 0 0 8 sscanf_s 
462 12 TIXML_STRING 0 0 0 0 0 11 std::string 
4
463 19 TIXML_MAJOR_VERSION 0 3 394 316 0 19 TIXML_MAJOR_VERSION 0

464 19 TIXML_MINOR_VERSION 0 3 394 317 0 19 TIXML_MINOR_VERSION 0

465 19 TIXML_PATCH_VERSION 0 3 394 318 0 19 TIXML_PATCH_VERSION 0

466 22 TIXML_DEFAULT_ENCODING 0 3 397 324 0 22 TIXML_DEFAULT_ENCODING 0

0
